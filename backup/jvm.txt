运行时数据区域：
java虚拟机在执行程序时会把它所管理的内存划分成若干个不同的数据区域。

运行时数据区域包括：
方法区（运行时常量池）
堆（java堆）
虚拟机栈
本地方法栈
程序计数器

线程共享：方法区、堆
1、方法区：存储类信息、常量、静态变量、即时编译期编译后的代码

2、堆：存储对象实例、数组
（堆大小设置，最大上限：-Xmx，初始内存大小分配：-Xms）

线程私有：程序计数器、虚拟机栈、本地方法栈

1、程序计数器：指向当前线程正在执行的字节码指令地址
为什么需要程序计数器？
线程切换的时候需要记录当前线程执行的位置，确保多线程情况下程序的政策执行。

2、虚拟机栈：存储当前线程运行方法所需要的数据、指令、返回地址。
虚拟机栈里边存储的是栈帧。
栈帧里边内容包括：局部变量表、操作数栈、返回地址、动态连接 。
局部变量表（LocalVariableTable）：第一个位置存储的是this（类对象本身），之后存储的是方法的传参。
操作数栈（Code）：一大堆指令，程序就是依靠一条条指令执行实现的。
返回地址：记录返回地址，方法正常执行完后告诉虚拟机需要返回到哪里。
	比如：a方法里边执行了b方法，b的栈帧的返回地址就会记录a方法的地址，当b方法执行完了就会回到a方法对应的地方。（如果执行中发生异常，是去到异常处理器表）
动态连接：用来实现多态的。在类加载的时候记录当前具体是哪个实例的方法。
	比如：B、C类继承自A，B、C分别实现了A中的aa方法，B、C实现的aa方法是有区别的。aa方法中的动态连接就是为了记录当前实例到底是B还是C。

注意：虚拟机栈是有大小的（大小设置：-Xss），如果递归很深可能会导致虚拟机栈溢出（StackOverflowError）。

3、本地方法栈：存储当前线程所使用的native方法的信息。
当线程里边有调用native方法的时候，并不会在虚拟机栈中创建栈帧，而是在本地方法栈中创建。



虚拟机中的对象
虚拟机遇到一条new指令时：
1）检查加载
先执行相应的类加载过程。
2）分配内存
	指针碰撞
		接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。
		如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。
	空闲列表
		如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。
		选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
	并发安全
		除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。
	CAS机制
		解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；
		分配缓冲
		另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数 -XX:UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。
		TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。
		TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。
3）内存空间初始化
（注意不是构造方法）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
4）设置
接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。
5）对象初始化
在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。


虚拟机优化：逃逸分析
几乎所有的对象都是在堆中分配的，但是也有例外。

逃逸分析：可以在栈上创建对象
基本思想：对于线程私有的对象，将它打散分配在栈上而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。
逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，任何可以在多个线程之间共享的对象，一定都属于逃逸对象。
public void test(int x,inty ){
String x = “”;
User u = ….
….. 
}
User类型的对象u就没有逃逸出方法test。
public  User test(int x,inty ){
String x = “”;
User u = ….
….. 
return u;
}
User类型的对象u就逃逸出方法test。

如何启用栈上分配（+是开启，-是关闭）
-XX:+DoEscapeAnalysis：开启逃逸分析(默认打开)
-XX:+UseTLAB 开启本地线程分配缓冲（默认打开，只有开启了 本地线程分配缓冲才能使用栈上分配）

-XX:+EliminateAllocations：标量替换(默认打开，)

-XX:+PrintGC：开启GC日志


测试：a方法内创建一个对象，然后a方法循环调用一亿次。
关闭逃逸分析：会出现频繁gc，最终一亿次执行时长大概接近1秒（这一亿个对象都是在堆创建的，导致出现大量gc）
开启逃逸分析：一亿次执行时长大概7、8毫秒（栈上创建，只创建了一次对象，创建到了缓存中。重复执行a方法直接从缓存取了）
