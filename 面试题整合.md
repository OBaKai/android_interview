## Java

#### 并发编程

（并发的更多问题：[Java并发编程 I - 并发问题的源头](https://blog.csdn.net/yudan505/article/details/117841171)）

1. 为什么会出现并发问题？

2. volatile能解决并发中的什么问题？

3. ThreadLocal怎么保证线程唯一？

4. sleep与wait的区别。+2

5. synchronize修饰方法和修饰静态方法的区别。+2

6. 写出一个死锁的例子。

7. List的加锁要如何加。

8. 多线程加锁的几种方法。+2

   

#### GC

1. gc泄漏在什么情况下出现？怎么解决？
2. 说说对垃圾回收器的理解。+3



#### 语法相关

1. final、finally、finalize()的区别。+2

2. 说说Java四种引用，以及用到的场景。+2

3. 弱引用与强引用的区别 ，怎么判断一个弱引用被回收了 。

4. StringBuffer、StringBuilder的区别。

5. equals与==的区别。

6. String a="a"与String a = new String("a")的区别。+2

   

#### 集合相关

1. Arraylist和Linklist的区别。+3

2. HashMap扩容条件中链表转红黑树的条件是什么？

3. HashMap扩容条件为什么要2的指数次幂，如果输入17会是多少容量？（跟hashcode有关，输入17得出结果是32）

4. CurrentHashMap 读写锁是如何实现的。（无hash冲突用CAS插入，有则用synchronize加锁插入。当链表长度大于8且数据长度>=64的时候会用红黑树代替链表）

   

#### 其他

1. 动态代理传入的参数有哪些？非接口类能实现动态代理吗？ASM的原理是什么？



## Android

#### Context

1. 说说你对Context的了解。

2. Activity、Context、Application三者有什么不同。+2

3. Intent的作用。

   

#### Activity

1. bundle的数据结构，如何存储。
2. 说说bundle机制。+2
3. 为什么bundle无法传大图片。
4. Bunder传输对象为什么需要序列化？Serialzable与Parcelable的区别。
5. 说说Activity的启动模式，分别在什么场景使用？+3
6. Activity横竖屏切换的生命周期。+3
7. 说说Activity的启动流程。
8. Activity、View、Window的三者的关系。+2
9. activity.startActivity与context.startActivity的区别。
10. 如何保存Activity的状态？
11. onSaveInstanceState()与onRestoreIntanceState()作用是什么。



#### Service

1. startService、bindService的区别？生命周期一样吗?

2. 启动service的两种方式以及其适用场景。

3. Service是否在 main thread执行，service里能否执行耗时操作？为什么？

4. Service与Activity 是在同一个线程吗？为什么？

   

#### BroadcastReceiver

1. 说说Broadcast的注册方式与区别。+3

   

#### Fragment

1. Fragment 的生命周期。+3

2. Activity和Fragment有哪些生命周期？+2

3. Fragment在Activity中replace的生命周期。

4. Fragment在Activity中replace，并addToBackStack的生命周期。

5. Fragment在ViewPager中切换的生命周期。

   

#### Handler

（handler的更多问题：[面试中 - Handler引发的那些灵魂拷问](https://blog.csdn.net/yudan505/article/details/113716381)）

1. Looper死循环为什么不会触发ANR？+4

2. 说说android消息机制。

3. 两个线程能使用handler通讯吗？为什么？

4. HandlerThread是什么？

5. 单线程模式中Message、Handler、MessageQueue、Looper之间的关系。

6. Handler的post(runnable)是如何实现的。callback、runnable、msg的优先级。

7. Handler的阻塞是如何实现的。

   

#### RecycleView

1. RecycleView与ListView的区别。+2
2. 说说对RecycleView的了解。



#### View

1. Activity、Window、DecorView的关系。+2

   ```
   android系统上所有的界面都是靠Window机制显示的。每个Activity、Dialog背后也都是Window。
   
   PhoneWindow是Window唯一的实现类，Activity持有一个PhoneWindow，而PhoneWindow持有一个DecorView，而我们写的界面全都是在DecorView上显示的。
   PhoneWindow在addView时会创建一个ViewRootImpl，让ViewRootImpl持有DecorView。
   ViewRootImpl与WMS通讯，ViewRootImpl是真正绘制DecorView的地方。
   ```

   

2. 说说view的绘制流程。+4

   ```
   PhoneWindow对象创建：
   startActivity -> AMS -> ActivityThread#handleLaunchActivity -> ActivityThread#performLaunchActivity -> Activity#attach -> new PhoneWindow()
   
   DecorView对象的创建：
   Activity#onCreate() -> setContentView -> new DecorView()
   
   addView DecorView：
   Activity#onResume() -> PhoneWindow#addView -> new ViewRootImpl() -> ViewRootImpl#setView -> ViewRootImpl#requestLayout
   
   requestLayout -> scheduleTraversals -> mChoreographer#postCallback -> TraversalRunnable -> doTraversal -> performTraversals
   ViewRootImpl#performTraversals()：
   performMeasure -> DecorView#measure -> DecorView#onMeasure -> ViewGroup#measure
   performLayout -> DecorView#layout -> DecorView#onLayout -> ViewGroup#layout
   performDraw -> DecorView#draw -> DecorView#onDraw -> ViewGroup#draw
   
   总结：
   startActivity->onCreate->完成DecorView的创建-
   >onResume()->DecorView添加到ViewRootImpl->ViewRootImpl.performTraversals()
   方法，测量（measure）,布局（layout）,绘制（draw）, 从DecorView自上而下遍历整个View树。
   
   Measure：测量视图宽高。 单一View:measure() -> onMeasure() -> getDefaultSize() 计算View的宽/高值 -> setMeasuredDimension存储测量后的View宽 / 高 
   ViewGroup: -> measure() -> 需要重写onMeasure( ViewGroup没有定义测量的具体过程，因为ViewGroup是一个抽象类，其测量过程的onMeasure方法需要各个子类去实现。
   如：LinearLayout、RelativeLayout、FrameLayout等等，这些控件的特性都是不一样的，测量规则自然也都不一
   样。)遍历测量ViewGroup中所有的View -> 根据父容器的MeasureSpec和子View的LayoutParams等信息计算子
   View的MeasureSpec -> 合并所有子View计算出ViewGroup的尺寸 -> setMeasuredDimension 存储测量后的宽 / 高
   从顶层父View向子View的递归调用view.layout方法的过程，即父View根据上一步measure子View所得到的布局大小
   和布局参数，将子View放在合适的位置上。
   
   Layout：先通过 measure 测量出 ViewGroup 宽高，ViewGroup 再通过 layout 方法根据自身宽高来确定自身
   位置。当 ViewGroup 的位置被确定后，就开始在 onLayout 方法中调用子元素的 layout 方法确定子元素的位置。子元素如果是 ViewGroup 的子类，又开始执行 onLayout，如此循环往复，直到所有子元素的位置都被确定，整个
   View 树的 layout 过程就执行完了。
   
   Draw：绘制视图。ViewRoot创建一个Canvas对象，然后调用OnDraw()。六个步骤：①、绘制视图的背景；
   ②、保存画布的图层（Layer）；③、绘制View的内容；④、绘制View子视图，如果没有就不用；⑤、还原图层
   （Layer）；⑥、绘制View的装饰(例如滚动条等等)。
   ```

   

3. 聊聊ViewGroup的测量、布局过程。

   ```java
   ViewGroup怎么执行测量的：
   以LinearLayout为例，在onMeasure方法里边会先区分横竖方向的测量。以竖向的测量为例子。
   第1次遍历子View：
   如果Layout是精确模式高度已经固定了，子View的大小就随意了反正超不过父。并且带权重的View能分到的高度也已经固定了，在第2次遍历的时候再给带权重的View分配高度。
   如果Layout是AT_MOST模式，需要测量子View才能确定父的高度，所以需要调用子View的measure来自测量，带权重的View也需要并且让它按WRAP_CONTENT标准来测量。
   第2次遍历子View：
   如果有带权重的View，给带权重的View分配高度。制造出一个带精确值的MeasureSpec，然后丢给有带权重的View让其自测量。
   总结：
   第1次遍历：算高度、宽度。跳过带权重的子View。
   第2次遍历：补充给带权重的子View测量高度。
     
   
   View的布局过程：
   以LinearLayout为例，在onLayout方法里边也是分横竖布局的。还是以竖向为例子。
   根据自身的重力配置（Gravity）计算子View的top应该从哪个位置开始。
   然后开始遍历子View，通过子View的测量宽高，然后计算出每个View对应的left、top，然后调用view的layout方法。
   ```

   

4. View必须在主线程刷新吗？

   ```JAVA
   ViewRootImpl#requestLayout 都会先执行 ViewRootImpl#checkThread（检查当前线程）
     
   怎么才能在子线程刷新ui？
   1. 在onResume()之前刷新，因为ViewRootImpl还没创建。
   2. 不触发requestLayout。比如设置textView固定宽度，然后setText。
   ```

   

5. 如何自定义控件。+3

   ```java
   自定义View: 只需要重写onMeasure()和onDraw()
   自定义ViewGroup: 则只需要重写onMeasure()和onLayout()
   ```

   

6. 说说MeasureSpace。+2

   ```java
   测量规格，View是根据它来决定自己的大小。
   32位int：高2位mode，低30位size。
   3种mode：
   未知（UNSPECIFIED）：父视图不约束子视图View，一般我们用不上（系统内部，ScrollView）
   精确（EXACTLY）：父视图为子视图指定一个确切的尺寸（match_parent、具体值）
   尽可能大（AT_MOST）：父视图为子视图指定一个最大尺寸，子视图必须确保自身 & 所有子视图可适应在该尺寸内（wrap_content）
   
   MeasureSpec从哪里来的：
   由于绘制流程从DecorView开始，而DecorView的MeasureSpec是通过
   ViewRoomImpl#getRootMeasureSpec制造出来的，ViewRoomImpl会根据屏幕宽高以及DecorView的测量模式制造出对应的MeasureSpec。
   一般Activity的DecorView宽高都是MATCH_PARENT，所以测量模式为EXACTLY。而Dialog的DecorView宽高可能都是WRAP_CONTENT，所以测量模式为AT_MOST。
   ViewGroup以及View的MeasureSpec都是依靠父布局的MeasureSpec加上自身测量得到的。
   ```

   

7. 子View创建MeasureSpace的规则是什么。

   ```java
   根据父容器的MeasureSpec和子View的LayoutParams等信息计算子View的MeasureSpec
   
   当View是具体值：精确模式 + 具体值
   当View是match_parent：父容器测量模式 +（a.父为精确模式，子大小为父的剩余大小；b.父为AT_MOST，子大小不会超过父的剩余大小）
   当View是wrap_content：AT_MOST + 不超过父的剩余大小
   ```

   

8. 为什么自定义View设置wrap_content不起作用的？

   ```java
   getDefaultSize方法：
   在测量过程中setMeasuredDimension的时候会用到getDefaultSize方法。
   getDefaultSize的默认实现中，当View的测量模式是AT_MOST或EXACTLY时，View的大小都会被设置成子View MeasureSpec的specSize。
   因为AT_MOST对应wrap_content；EXACTLY对应match_parent，所以，默认情况下，wrap_content和match_parent是具有相同的效果的。
   
   specSize从哪里来：
   在计算子View测量尺寸方法getChildMeasureSpec()中，子View MeasureSpec在属性被设置为wrap_content或match_parent情况下，子View MeasureSpec的specSize被设置成parenSize=父容器当前剩余空间大小
     
   所以：wrap_content起到了和match_parent相同的作用：等于父容器当前剩余空间大小
   ```

   

9. getWidth与getMeasureWidth区别。

   ```java
   getWidth与getMeasureWidth区别: 在大多数情况下两者的值是相同的。但是值生成时机不同。
   getMeasureWidth在measure之后就是有效值了，而getWidth要在layout之后才能是有效值。
   getWidth -> mRight - mLeft
   getMeasureWidth -> mMeasuredWidth & MEASURED_SIZE_MASK
   在布局过程中，调用child.layout的时候传入的right就是用 left + child.getMeasuredWidth
   
   值不同的情况：重写了View#layout，手动地改了right的值。
   ```

   

10. Activity中获取某个View的宽高有几种方法？

    ```java
    1. Activity/View#onWindowFocusChanged：此时View已经初始化完毕，当Activity的窗口得到焦点和失去焦
    点时均会被调用一次，如果频繁地进行onResume和onPause，那么onWindowFocusChanged也会被频繁
    地调用。
    2. view.post(runnable)： 通过post将runnable放入ViewRootImpl的RunQueue中，RunQueue中runnable
    最后的执行时机，是在下一个performTraversals到来的时候，也就是view完成layout之后的第一时间获取
    宽高。
    3. ViewTreeObserver#addOnGlobalLayoutListener：当View树的状态发生改变或者View树内部的View的可
    见性发生改变时，onGlobalLayout方法将被回调。
    ```

    

11. 为什么onCreate、onResume获取不到View的宽高？

    ```java
    因为View的绘制流程是在onResume之后才进行的。
    在onResume之后，DecorView才被add到WindowManger，这时才与ViewRoomImpl关联，才开始走绘制流程。
    只有走完测量流程，View才能获取到宽高。
    ```

    

12. requestLatout()与invalidate()的区别。

    ```java
    requestLatout：走三大流程
    	设置该view自己的flag（mPrivateFlags）为PFLAG_FORCE_LAYOUT，并且调用父布局的requestLayout。
    一直会去到ViewRoomImpl的requestLayout，然后就走绘制的三大流程。
    measure：
      如果自己的flag为PFLAG_FORCE_LAYOUT，执行onMeasure。并且设置flag为PFLAG_LAYOUT_REQUIRED。
    layout：
      如果自己的flag为PFLAG_LAYOUT_REQUIRED，执行onLayout。
    
    
    invalidate：只走draw流程
      设置自己的flag为PFLAG_DIRTY，并且调用父布局的invalidateChild。
    一直会去到ViewRoomImpl的invalidateChildInParent，其实最终也是执行绘制三大流程。
    不过由于flag值不同，最终view只会走了draw流程。
    ```

    

13. invalidate()和 postInvalidate() 的区别。

    ```java
    invalidate()只能在ui线程调用。
      
    postInvalidate()可以在子线程也可以在主线程调用。
    其内部就是多了个handler切回主线程的操作，最终也是调用invalidate()。
    ```

    

14. 说说view.post跟handler.post的区别。

    ```java
    public boolean post(Runnable action) {
            final AttachInfo attachInfo = mAttachInfo;
            if (attachInfo != null) {
                return attachInfo.mHandler.post(action);
            }
            getRunQueue().post(action);
            return true;
        }
    
    handler.post：
    是直接add到MessageQueue里边的，loop到它就会执行。
     
    view.post：
    如果View已经attach到window，直接调用UI线程的handler.post。
    如果View还未attach到window，将Runnable放入View内部的一个队列HandlerActionQueue中，等到执行attach的时候在从队列拿出Runnable，再调用UI线程的handler.post。
    ```

    

#### 动画

1. 简单说明android中的几种动画，以及他们的特点和区别。



#### Drawable与Bitmap

1. 如果对bitmap进行压缩。
2. 图片资源放在不同文件夹中，加载出来的内存占用分别是多少，为什么会这样？



#### 事件分发

1. 触摸事件是如何传递的。+5
2. 事件分发是使用了什么设计模式？（责任链模式）
3. 如果解决滑动冲突？+2
4. 同时给一个view和viewgroup设置了点击事件优先响应那个，为什么  ？



#### 数据存储

1. SharedPreference能多进程访问吗？进程间数据共享有什么方式？
2. SharedPreference是如何存储的？存储位置在哪里？
3. 内部存储与外部存储的区别？
4. android 有哪些数据存储方式。+2



#### 性能优化

1. 内存泄漏是如果产生的？如何解决？+3

2. 内存泄漏与内存抖动的区别。+3

3. 怎么app优化启动速度。

4. 如何监测内存泄漏。

5. 什么是ANR，如何避免它？

6. 如何进行app性能优化、内存优化、cpu使用率优化？

7. 内存泄漏的分类。如何分析内存泄漏问题。

8. native崩溃日志如何采集，怎么处理？

   

#### Apk与打包流程

1. apk如何脱壳。

2. 如何进行多渠道打包？

3. 打包app如何进行加固与混淆？

4. 如何进行apk瘦身？

5. 讲述下android的数字签名。

6. apk打包过程中aar中是否包含R文件。

7. jar、aar的区别。

8. V1、V2、V3签名有什么区别。

   

#### 进程间通讯

1. android进程间通讯方式有哪些？
2. binder优势是什么？
3. 说说aidl生成java类的细节。
4. 进程间通讯遇到过哪些问题？



#### Framework

1. 说说view的渲染过程（WMS）。+2
2. 说说app的启动流程。+2
3. launcher启动程序 跟 另一个程序跳转过去两者有什么区别？
4. Activity是在哪里创建的。Application是在哪里创建的。与AMS是如何交互的。
5. 说说类加载器的双亲委托机制。



#### 功能设计相关

1. 如何设计一个类似微信朋友圈首页功能，包括UI、数据等方面。
2. 如何设计一个无线数据的气泡显示聊天内容。
3. 大文件在传输过程中需要考虑哪些问题，如果保证一致性。
4. 如何做到单个信号源，多个页面响应。
5. 设计一个日志系统。



#### 其他

1. 怎么终止一个app?
3. 说说进程如何保活。+2
4. 说说屏幕适配方案。+2
4. 说说android中进程优先级。
5. AsyncTask是什么，使用方法，使用时候需要注意什么？
6. 说说AsyncTask的原理，聊聊它的缺陷和问题。
7. 聊聊android各个版本的新特性。
8. android为每个应用程序分配的内存是多少。
9. JSbridge是如何实现js与native联通的。



## Android第三方库

#### RxJava

#### OKHttp

#### Retrofit

1. 说说你对retrofit的了解。

   

#### Glide



#### Databinding

1. 说说databinding的原理。

   

#### 插件化

1. 启动Activity的hook方式。taskAffity。

   

#### 其他

1. 组件化中module和app之间的区别。module通信是如何实现的。



## Kotlin

#### 协程

1. 说说kotlin的协程。+3
2. 概括一下kotlin协程的上下文。
3. 协程是如何挂起的。



#### 语法相关

1. 高阶函数是什么？
2. ==与===的区别。
3. lateinit与lazy的区别。



#### 其他

1. kotlin与java有什么区别。+3
2. kotlin有什么优缺点？+2
3. kotlin的lambda与java的lambda有什么区别。



## NDK

#### JNI

1. jni的注册方法有哪些。+2

2. JNIEnv *env是什么？有什么用？

   

#### C++相关

1. 函数指针如何写？

2. c++中构造函数的调用顺序，析构函数是否需要virtual。

3. . 与 -> 的区别。哪个性能更高。

4. :: 与 : 的区别。

   

#### 其他

1. 视频编解码是怎么做的。



## 网络编程

#### Http

1. Http与Https的区别

2. 什么是Http协议。协议包含什么，请求头，和token怎么传。

3. http2的功能有哪些？

   

#### Https

1. https是如何加密的？+3

   

#### 其他

1. 域名遭到劫持的解决方案。
2. 如何防抓包。



## 数据结构与算法

#### 数据结构

1. 红黑树的特点。

2. 求二叉树中两个节点之间的最大距离。+2

3. 手写一个冒泡排序。

4. 栈与队列的区别。

5. 你了解几种排序？说说各自优点。

   

#### 算法

1. ()[]{}有效括号问题。

5. 1亿个数，其中一个数出现了两次，在内存紧张的情况下如何快速这个重复的数？

7. 100 匹马驮100筐水果，大马驮3匡,中马驮2匡,小马驮半框，求大马中马小马各有多少匹?

8. 请手写代码完成阶乘函数，n! = n* (n-1)* (n-2)* .. 1(n>0) 。

9. 将34669987转化成中文（例如222->二百二十二）。

10. 斐波那契数列。

11. n块糖每次只能吃1至2块,全部吃完有几种方法?

12. 36辆车，6条跑道，无计时器，最少几次比赛可以选出前三。

9. 5个G的数据，如何在500M内存的条件下实现排序。

10. 三色球排序。

    

#### 字符串相关

1. 手机号码中间+ **** 有几种方式。



## 设计模式

1. 适配器和装饰器模式各自特点和使用场景。

   
