## protobuf优缺点

```java
protobuf跟json、xml一样，是一种数据格式。

json本质是一种带格式的字符串。由于数据传输只能传输字节数组，所以json序列化过程是这样的：
java对象 -> json字符串 -> 字节数组
  
protobuf直接就是以字节流方存在的，序列化后直接就是字节数组了。
java对象 -> 字节数组

  
1 与json相比，protobuf优点与缺点
优点：序列化/反序列化效率更高；空间占用更低。
缺点：可读性差

1.1 序列化/反序列化效率更高
① 序列化的数据量少，效率就高
  json字符串的序列化，它结构里边就包含了大量的key字符串、‘:’、‘{}’等，
  protobuf则是没有这些，key也使用数字取代，属性跟属性之间非常紧凑。
    
② 序列化的复杂度
  json：java对象 -> json字符串 -> 字节数组
  protobuf：java对象 -> 字节数组
  json本质是就是对整个字符串的编码，而protobuf是根据不同类型的属性有不用的编码方式。
    
③ protobuf在某些类型的属性编码中使用小端序排列字节，充分利用了CPU读取内存数据的习惯（CPU读取数据都是小端序的）

1.2 空间占用更低
① 不使用字符串作为属性key值，而是使用整数来作为key值
② 大量使用了varint整数压缩算法
```



## protobuf序列化分析

### pb例子

```java
//定义
message User {
  int32 userId = 1;
}

//使用
User user = User.newBuilder().setUserId(300).build();
System.out.println(user); //输出：userId：300
byte[] data = user.toByteArray();
for (byte b : data) { 
	System.out.printf("%02X", b & 0xFF); //输出：08AC02
}
```



### pb分析（tag-value 或 tag-length-value 规则）

```java
16进制：08AC02
2 进制：0000 1000 1010 1100 0000 0010
  
pb序列化规则（tag-value 或 tag-length-value 规则）
```



#### varints数据压缩算法

```java
varint数据压缩算法：一种将整数用1个或者多个字节表示的一种序列化方法，越小的数使用越少的字节。
例如：java中int占4个字节，假设一个int值为1，那么它也是占用4个字节就浪费空间了。varint可以让它只占用一个字节。

  
最高有效位：一个字节8位中最高位中如果是1表示后面字节是和该字节连续在一起的，也是该数据的一部分。如果是0表示计算终止。
例如 10001000 00010001
10001000最高位为1，后面一个字节也是它的数据（也就是00010001）。
00010001最高位为0，也就是说到它这个字节数据就结束了。
所以真正存数据内容，就是除去最高位后剩下的那7位，也就是 0001000 以及 0010001
  
  
也就是说使用varint算法的字节，一个字节只能表示0-128之间的数。更大的数就需要增加字节。
```



#### 字节序（大端序、小端序）

```java
字节序：在计算机领域中，指电脑内存中或在数字通信链路中，占用多个字节的数据的字节排列顺序
例如：Go语言中，一个类型为int的变量x地址为0x100，那么其指针&x的值为0x100。且x的四个字节将被存储在内存的0x100, 0x101, 0x102, 0x103位置
  
  
字节的排列方式有两种：
大端序：将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址。
这种排列方式与数据用字节表示时的书写顺序一致，符合人类的阅读习惯。
  
小端序：将一个多位数的低位放在较小的地址处，高位放在较大的地址处。
小端序与人类的阅读习惯相反，但更符合计算机读取内存的方式，因为CPU读取内存中的数据时，是从低地址向高地址方向进行读取的。
  
例如：整数168496141需要4个字节存储，这个数值的对应的16进制表示是0x0A0B0C0D
地址：0x01 0x02 0x03 0x04 0x05...（内存地址从低到高）
大端：0x0A 0x0B 0x0C 0x0D（0x0A0B0C0D，高位是0x0A、低位是0x0D）
小端：0x0D 0x0C 0x0B 0x0A
  
  
为什么要有字节序?
计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。
计算机的内部处理都是小端字节序。在计算机内部，小端序被广泛应用于现代 CPU 内部存储数据；而在其他场景，比如网络传输和文件存储则使用大端序。
  
  
总结：
计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合比如网络传输和文件储存，几乎都是用的大端字节序。正是因为这些原因才有了字节序。
计算机处理字节序的时候，如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序则正好相反。
```



#### pb使用了 varint + least significant group first（小端序）

```java
pb在整数中使用了varint数据压缩算法，上边有介绍varint。
pb对多字节数据使用了least significant group first（小端序）。
  
例如：例如300这个整数，在pb中是序列化后是 0xAC02
十六制：0xAC02
二进制：10101100 00000010
varint算法：去掉高位，得到 0101100 与 0000010
  1 0101100
  0 0000010
least significant group first处理（把低位放到高位，高位放低位）：
  0101100是在低位，0000010是在高位
  经过处理得到的是：00000100101100 转成十进制就是300
```

#### tag（使用了varints算法）

```java
tag构成：field_number + wire_type
	field_number：就是我们定义的属性值，userId = 1中的1
	wire_type：官方定义的种类，官方有提供对照表。例如：int32的值为0
  	0 varint int32 int64 uint32 uint64 sint32 sint64 bool enum
    1 64位长度 fixed64 sfixed64 double
    2 value的长度 string bytes message packed repeated fiels
    ...
  
tag计算公式：(field_number << 3) | wire_type
  
  
tag注意：tag占1字节，如果field_number超过了15，那么tag会变成占用2个字节
  原因：tag使用了varint算法，所以占用了高位，剩下7位可用。
  	   field_number左移3位，那么field_number只能使用到4位了，其余3位是wire_type的。
       4位最多只能表示到15（二进制：1111），所以超过15就需要扩展增加字节
```



#### length（使用了varint算法）

```java
当tag中的wire_type类型为2的时候，属性就需要额外存放length值。（字符串属性、标记repeated的属性（列表数据））
例如：0x0A0441424344
tag：0x0A -> wire_type是2
那么0x04就是length，表示value长度
value：0x41424344（字符串"ABCD"，ASCII就是 41 42 43 44）
```



#### value（如果wire_type是0，value值也使用了varint算法）

```java
根据wire_type的类型，存储不同类型的数据。
```



#### 负数（使用sint32/sint64类型，因为它们会用到ZigZag编码）

```java
如果某个属性可能出现负数，那么最好使用sint32/sint64类型。

使用varint编码
32位整型数据经过Varint编码后需要1~5个字节，小的数字使用1个byte，大的数字使用5个bytes。
64位整型数据编码后占用1~10个字节。
在实际场景中小数字的使用率远远多于大数字，因此通过Varint编码对于大部分场景都可以起到很好的压缩效果。

但是：
使用varint对32位负数进行编码，恒定占用5个字节
使用varint对64位负数进行编码，恒定占用10个字节
  
所以需要引入 ZigZag编码
ZigZag编码：对负数做一次变换将其映射为一个正数
变成正数之后就能够用varint算法进行优化了。

这里关键的一点在于变换的算法，该算法必须是可逆的。就像可根据变换后的值还原原始值，否则就无法解码。
同时要求变换算法要尽可能简单，以避免影响Protobuf编码、解码的速度。

Zigzag(n) = (n << 1) ^ (n >> 31), n 为 sint32 时
Zigzag(n) = (n << 1) ^ (n >> 63), n 为 sint64 时
```



