## 网络编程

#### Http

##### Http与Https的区别

```java
Http存在着这些缺点：
通信使用明文，内容可能被窃听(重要密码泄露)
不验证通信方身份，有可能遭遇伪装(跨站点请求伪造)
无法证明报文的完整性，有可能已遭篡改(运营商劫持)

Https是在http协议基础上加入 加密处理、认证机制、完整性保护。（http+加密+认证+完整性保护=https）
```



##### Http如何下载大文件？

```java
使用断点续传：
一个最简单的断点续传实现大概如下：
1.客户端下载一个1024K的文件，已经下载了其中512K。
2. 网络中断，客户端请求续传，因此需要在HTTP头中申明本次需要续传的片段：Range:bytes=512000-
这个头通知服务端从文件的512K位置开始传输文件。
3. 服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：Content-Range:bytes 512000-/1024000
并且此时服务端返回的HTTP状态码应该是206，而不是200。

但是在实际场景中，会出现一种情况，即在终端发起续传请求时，URL对应的文件内容在服务端已经发生变化，此时续传的数据肯定是错误的。如何解决这个问题了？显然此时我们需要有一个标识文件唯一性的方法。在RFC2616中也有相应的定义，比如实现Last-Modified来标识文件的最后修改时间，这样即可判断出续传文件时是否已经发生过改动。同时RFC2616中还定义有一个ETag的头，可以使用ETag头来放置文件的唯一标识，比如文件的MD5值。

终端在发起续传请求时应该在HTTP头中申明If-Match 或者If-Modified-Since 字段，帮助服务端判别文件变化。

另外RFC2616中同时定义有一个If-Range头，终端如果在续传是使用If-Range。If-Range中的内容可以为最初收到的ETag头或者是Last-Modfied中的最后修改时候。服务端在收到续传请求时，通过If-Range中的内容进行校验，校验一致时返回206的续传回应，不一致时服务端则返回200回应，回应的内容为新的文件的全部数据。


```



##### Http 怎么支持断点续传的？

```java
Http1.1协议中默认支持获取文件的部分内容，这其中主要是通过头部的两个参数：Range 和 Content Range 来实现的。客户端发请求时对应的是 Range ，服务器端响应时对应的是 Content-Range。
  
Range：
客户端想要获取文件的部分内容，那么它就需要请求头部中的 Range 参数中指定获取内容的起始字节的位置和终止字节的位置，它的格式一般为：
Range:(unit=first byte pos)-[last byte pos]
例如：
Range: bytes=0-499      表示第 0-499 字节范围的内容 
Range: bytes=500-999    表示第 500-999 字节范围的内容 
Range: bytes=-500       表示最后 500 字节的内容 
Range: bytes=500-       表示从第 500 字节开始到文件结束部分的内容 
Range: bytes=0-0,-1     表示第一个和最后一个字节 
Range: bytes=500-600,601-999 同时指定几个范围

Content Range：
在收到客户端中携带 Range 的请求后，服务器会在响应的头部中添加 Content Range 参数，返回可接受的文件字节范围及其文件的总大小。它的格式如下：
Content-Range: bytes (unit first byte pos) - [last byte pos]/[entity legth]
例如：
Content-Range: bytes 0-499/22400    // 0－499 是指当前发送的数据的范围，而 22400 则是文件的总大小。
  
使用断点续传和不使用断点续传的响应内容区别：
不使用断点续传：HTTP/1.1 200 Ok
使用断点续传：HTTP/1.1 206 Partial Content
  
处理请求资源发生改变的问题：
在现实的场景中，服务器中的文件是会有发生变化的情况的，那么我们发起续传的请求肯定是失败的，那么为了处理这种服务器文件资源发生改变的问题，在 RFC2616 中定义了 Last-Modified 和 Etag 来判断续传文件资源是否发生改变。
  Last-Modified & If-Modified-Since（文件最后修改时间）
  Last-Modified：记录 Http 页面最后修改时间的 Http 头部参数，Last-Modified 是由服务端发送给客户端的
  If-Modified-Since：记录 Http 页面最后修改时间的 Http 头部参数，If-Modified-Since 是有客户端发送给客户端的
```



##### http2的功能有哪些？

```java
HTTP/2通过以下方法减少延迟，用来改进页面加载的速度，
  HTTP Header的压缩，采用的是HPack算法。
  HTTP/2的Server Push，非常重要的一个特性。
  请求的pipeline。
  修复在HTTP 1.x的队头阻塞问题。
  在单个TCP连接里多工复用请求。
```



#### Https

##### https是如何加密的？+3

```java
TLS（SSL3.1就是TLS）是更为安全的升级版 SSL，ssl在应用层跟传输层之间）
tcp完成连接之后
客户端发送client hello （random_c + 一堆密码套件（假设x,y,z））
服务端发送server hello （random_s + 选了其中某个密码套件(假设选了x)）
服务端又发Server Key Exchange （服务端公钥）
服务端最后发送hello done

客户端验证发过来的服务端公钥
客户端根据 (random_c + random_s)x 生成 pre-master
客户端发送 (pre-master)(服务端公钥加密)

服务端收到(pre-master)(服务端公钥加密)后，用私钥解密得到 pre-master
服务端根据 (random_c + random_s)x 生成my_pre-master，pre-master 与 my_pre-master比对。

服务端发送 用pre-master加密的“Finished”消息。
客户端发送 也用pre-master加密的“Finished”消息。
完成tls握手
```





#### 其他

##### 域名遭到劫持的解决方案。

##### 如何防抓包。



## 加密

##### 什么是对称加密

```java
通信双⽅使⽤同⼀个密钥，使⽤加密算法配合上密钥来加密，解密时使⽤加密过程的完全逆过程配合密钥来进⾏解密。

应用：
  DES（56 位密钥，密钥太短⽽逐渐被弃⽤）、AES（128 位、192 位、256 位密钥，现在最流⾏）
  
优点：
  使用简单、效率高。
缺点：
  不能在不安全⽹络上传输密钥，⼀旦密钥泄露则加密通信失败。
  
破解思路：
  拿到⼀组或多组原⽂-密⽂对，设法找到⼀个密钥，这个密钥可以将这些原⽂-密⽂对中的原⽂加密为密⽂，以
  及将密⽂解密为原⽂的组合，即为成功破解。
```



##### 什么是非对称加密

```java
使⽤公钥对数据进⾏加密得到密⽂，使⽤私钥对数据进⾏解密得到原数据。

应用：
  数字签名技术：原数据进行hash后将hash值加密，原数据+加密hash传输。
  					  对方拿到数据后，解密hash并且自己也对原数据进行hash，两个hash比对，完成签名校验。
  经典的数据签名有：RSA（可⽤于加密和签名）、DSA（仅⽤于签名，但速度更快）
  
优点：
  可以在不安全⽹络上传输密钥。
缺点：
  计算复杂，因此性能相⽐对称加密差很多。
```



##### 什么是hash，hash有什么用途？

```java
定义：把任意数据转换成指定⼤⼩范围（通常很⼩，例如 256 字节以内）的数据。
作用：相当于从数据中提出摘要信息，因此最主要⽤途是数字指纹。

用途：
  唯⼀性验证：例如 Java 中的 hashCode() ⽅法。
  数据完整性验证：通过⽐对⽂件的 Hash 值（例如 MD5、SHA1）
  快速查找：HashMap
  隐私保护：当重要数据必须暴露的时候，例如⽹站登录时。可以只保存⽤户密码的Hash值，在每次登录验
					证时只需要将输⼊的密码的Hash值和数据库中保存的Hash值作⽐对就好
  
注意：
  hash不是编码。
  hash不是加密。
 	hash是单向过程往往是不可逆的，⽆法进⾏逆向恢复操作，不属于编码也不属于加密。
 （记住，MD5 不是加密！）
```



