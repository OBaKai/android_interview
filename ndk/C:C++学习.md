## C++ OOP



## 内存分配与释放

### 内存分区

```java
C/C++编译的程序占用的内存分为以下几个部分：

1.栈区：由编译器在需要的时候分配，在不需要的时候自动清除的存储区。一般是函数的参数值、局部变量的值等。
在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。
  
2.堆区：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收。
malloc申请内存，free释放内存。
注意在C++中还有一个‘自由存储区’，它由new申请内存，delete释放内存。
  
3.全局区（静态区）：全局变量分为初始化的和未初始化的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域。同时未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放。
  
4.字符串常量区：存放字符串常量。程序结束后由系统释放。
  
5.程序代码区：存放源代码和库的区域。
  
  
//案例：
int a = 0; //全局初始化区    
char *p1; //全局未初始化区    

int main(){    
  int b; //栈    
  char s[] = "abc"; //栈    
  char *p2; //栈    
  char *p3 = "123456"; //123456在常量区，p3在栈上。    
  static int c = 0；//全局（静态）初始化区    
  p1 = (char*) malloc(10);  //分配得来得10和20字节的区域就在堆区
  p2 = (char*) malloc(20);       
  strcpy(p3,"123456"); //123456放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。    
}    
```



### 堆区 与 自由存储区 的区别

```java
堆是C语言和操作系统的术语，堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，使用malloc、free来申请/释放内存。

而自由存储是C++中通过new、delete来分配/释放对象的抽象概念。
基本上所有的C++编译器默认使用堆来实现自由存储（也就是说自由存储区就位于堆上）
说默认下全局运算符new/delete，也许可以用malloc/free的方式申请和释放存储空间。
但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就不位于堆上了。
```



### new 与 malloc 的区别

```java
1、属性
new/delete是C++关键字，需要编译器支持。
malloc/free是库函数，需要头文件支持。

1、参数
new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。
malloc则需要显式地指出所需内存的大小。

2、返回类型
new操作符内存分配成功，返回的是对象类型的指针，无须进行类型转换，new是符合类型安全性的操作符。
malloc内存分配成功则是返回void*，需要通过强制类型转换将void*指针转换成我们需要的类型。

3、分配失败
new内存分配失败时，会抛出bac_alloc异常。
malloc分配内存失败时返回NULL。

4、自定义类型
new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。
malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

5、重载
C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。
malloc不允许重载。

6、内存区域
new操作符从自由存储区上分配内存空间。
malloc函数从堆区上分配内存空间。
基本上所有的C++编译器默认使用堆来实现自由存储（也就是说自由存储区就位于堆上）
```



## 智能指针

### C/C++指针问题

#### 1、野指针

```java
① 指针未初始化，当我们去判断一个指针是否可用时，往往会判断指针是否为NULL。
   未初始化的指针，它有可能指向了一个未知的地址。指针初始化是必须要养成的习惯。
  
② 将对象delete后，未将指向它的指针设为NULL，这种情况同指针未初始化一样。
  
③ 有多个指针指向了对象A，当某个地方将对象A delete后，操作地方的指针，就是对一个非法的内存进行操作
```



#### 2、new了对象后没有delete（内存泄漏）

```java
动态分配内存是需要程序员主动去删除的，不然会造成内存泄漏。
  
比如在一个函数中new了一个对象，并将这个对象作为返回值返回。对于一个多人维护的比较复杂工程，如果有这样的函数，并不一定所以人都会留意去释放内存，或者改对象需要被多个地方使用到，要在合适的地方去释放该对象不是那么好处理的。
```



### C++智能指针

```java
```



### Android中的智能指针

```java
轻量级指针（Light Pointer）
强指针（Strong Pointer）
弱指针（Weak Pointer）
轻量级指针采用的是简单的计数，可以认为是强指针的简化版本。
在播放器的C++代码中，特别是涉及到binder通讯的地方有很多智能指针的应用，比如jni中：
sp<MediaPlayer> mp = getMediaPlayer(env, thiz); //sp为强指针，lp为轻量级，wp为弱指针


为什么智能指针在c/c++开发中很少用到，而在Android源码里边大量使用？
智能指针好用，但是捆绑了平台。
用c/c++开发目的大部分都是为了跨平台，写一个库文件提供给win、ios、android多平台使用。
而智能指针只是Android封装的api，只有在Android平台才能使用。
```



## 语法相关问题

### 虚函数

#### 多态 - 静态绑定 与 动态绑定

```c++
静态绑定（编译时多态）：函数重载和运算符重载是编译时多态的完美例子。
相同名称但参数数量不同的函数，我们可以在函数调用时根据传递的参数的不同来确定要调了哪个函数（编译期间就能确定）
这就是为什么它被视为多态的一个例子，因为在不同的条件下输出是不同的。
//例子：
class Add {
public:
  int sum(int num1, int num2){ return num1+num2; }
  int sum(int num1, int num2, int num3){ return num1+num2+num3; }
};
int main() {
  Add obj;
  cout<<obj.sum(10, 20)<<endl; //输出：30
  cout<<obj.sum(11, 22, 33)<<endl; //输出：66
  return 0;
}

动态绑定（运行时多态）：函数覆盖是运行时多态的一个例子。
当子类声明一个已存在于父类中的方法时，这称为函数覆盖，这里子类覆盖父类。
class A {
public:
  void print(){ cout<<"aaa"<<endl; }
};
class B: public A{
public:
  void print(){ cout<<"bbb"<<endl; }
};
int main() {
  A a;
  a.print(); //输出：aaa
  B b;
  b.print(); //输出：bbb
  return 0;
}
```



#### 多态 - 虚函数与纯虚函数（动态绑定的一种）

```c++
1、非虚函数
//一个覆写非虚函数的例子
//尽管创建的是B的对象，但依旧是执行了父类的print()函数。
class A {
public:
  void print(){ cout<<"aaa"<<endl; }
};

class B: public A{
public:
  void print(){ cout<<"bbb"<<endl; }
};

int main() {
  A* obj = new B();
  obj.print(); //输出：aaa
  return 0;
}


2、虚函数
//在上边例子的基础上，给A类的print()函数增加关键字 virtual，使其成为虚函数
virtual void print(){ cout<<"aaa"<<endl; }

//再运行，输出：bbb
A* obj = new B();
obj.print(); //输出：bbb

由于我们将函数print()标记为虚函数，因此在运行时解析对函数的调用，编译器在运行时确定对象的类型并调用适当的函数。
  

3、纯虚函数 - 类型Java的抽象方法
class A {
public:
  virtual void print() = 0; //纯虚函数：标记了virtual，并且没有实现该函数（=0）
};

class B: public A{
public:
  //子类必须实现该函数
  void print(){ cout<<"bbb"<<endl; }
};
```



#### 虚函数表

```java
1、什么是虚表
虚函数主要通过虚函数表来实现。如果一个类里边有虚函数，该类就会产生一个虚函数表。不管多少个对象，都是用的是同一个虚表。

虚表：一个指针数组，存放着所有虚函数的指针。（注意：普通的函数调用并不需要经过虚表）
虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。

  
2、什么是虚表指针
虚表指针：虚表是属于类的，而不是属于某个具体的对象。但是为了让每个对象都能使用类中的虚表，编译器在类中添加了一个指针，*__vptr，用来指向虚表。
这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。
  
虚表是虚表，非虚函数不走虚表，基类的指针只能调用基类的方法,但是记住虚函数的指针是基类的，其他子类继承下来也只是继承了使用权
```





#### 虚函数的一些知识点

##### 为什么自定义类的析构函数必须是虚函数？为什么C++默认的析构函数却不是虚函数？

```java
为什么自定义类的析构函数必须是虚函数？
在用基类操作派生类时，为了防止执行基类的析构函数，不执行派生类的析构函数。因为这样的删除只能够删除基类对象, 而不能删除子类对象, 形成了删除一半形象, 会造成内存泄漏.
  
为什么C++默认的析构函数却不是虚函数？
C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。
而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。
因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。
```



##### 为什么调用普通函数比调用虚函数的效率高？

```java
因为普通函数是静态联编的，而调用虚函数是动态联编的。
联编的作用：程序调用函数，编译器决定使用哪个可执行代码块。（所谓联编就是将函数名和函数体的程序连接到一起的过程）
静态联编 ：在编译的时候就确定了函数的地址，然后call就调用了。
（静态联编本质是系统用实参与形参进行匹配，对于重名的重载函数根据参数上的差异进行区分，然后进行联编，从而实现编译时的多态。函数的选择基于指向对象的指针类型或者引用类型。）

动态联编 ： 首先需要取到对象的首地址，然后再解引用取到虚函数表的首地址后，再加上偏移量才能找到要调的虚函数，然后call调用。
（动态联编本质上是运行阶段执行的联编，当程序调用某一个函数时，系统会根据当前的对象类型去寻找和连接其程序的代码。函数的选择基于对象的类型。）
```



#### 为什么要用虚函数表（存函数指针的数组）？

```java
同一个类的多个对象的虚函数表是同一个，所以这样就可以节省空间，一个类自己的虚函数和继承的虚函数还有重写父类的虚函数都会存在自己的虚函数表。同时，虚函数表本质是一个地图导航，可以清楚告诉一个想要操作子类的父类指针到底该使用哪个函数。
```





### extern "C"的作用

```java
是让被作用的代码块采用c语言的编译规则编译

如果没加extern "C"：
运行的时候就会抛异常，找不到函数
定义的函数：Java_com_kobe_MainActivity_stringFromJNI
编译之后的函数：Z40Java_com_kobe_MainActivity_stringFromJNIP7_JNIEnvP8_jobject

C不支持函数的重载，编译之后函数名不变
C++支持函数的重载，编译之后函数名会变
静态注册的JNI接口，需要考虑C++编译之后函数名变化的问题，所以需要加上extern "C"的关键字。
动态注册的JNI接口，就不会有这个问题


源码是怎么使用的：头文件有可能被C语言或者C++语言使用，怎么做兼容
使用宏定义判断当前的编译器是不是c++编译器，这种使用技巧，可以说在android源码中随处可见
#if defined(__cplusplus)
extern "C" {
#endif
void *memset(void *s, int c, size_t n);
#if defined(__cplusplus)
}
#endif
```



1. 函数指针如何写？

2. c++中构造函数的调用顺序，析构函数是否需要virtual。

3. . 与 -> 的区别。哪个性能更高。

4. :: 与 : 的区别。


stl 容器 是否线程安全？

int a[100];
sizeof(a);

c++11后 一个空class有哪些方法，占多少字节
