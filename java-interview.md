## Java

#### 并发编程

（并发的更多问题：[Java并发编程 I - 并发问题的源头](https://blog.csdn.net/yudan505/article/details/117841171)）

1. 为什么会出现并发问题？

2. volatile能解决并发中的什么问题？

3. ThreadLocal怎么保证线程唯一？

4. sleep与wait的区别。+2

5. synchronize修饰方法和修饰静态方法的区别。+2

6. 写出一个死锁的例子。

7. List的加锁要如何加。

8. 多线程加锁的几种方法。+2

9. 开启线程的三种方式？

10. 线程和进程的区别？+2

11. run()和start()方法区别

12. 两个进程同时要求写或者读，能不能实现？如何防止进程的同步？

    

#### JVM

```java
运行时数据区域：
java虚拟机在执行程序时会把它所管理的内存划分成若干个不同的数据区域。

运行时数据区域包括：
方法区（运行时常量池）
堆（java堆）
虚拟机栈
本地方法栈
程序计数器

线程共享：方法区、堆
1、方法区：存储类信息、常量、静态变量、即时编译期编译后的代码

2、堆：存储对象实例、数组
（堆大小设置，最大上限：-Xmx，初始内存大小分配：-Xms）

线程私有：程序计数器、虚拟机栈、本地方法栈

1、程序计数器：指向当前线程正在执行的字节码指令地址
为什么需要程序计数器？
线程切换的时候需要记录当前线程执行的位置，确保多线程情况下程序的政策执行。

2、虚拟机栈：存储当前线程运行方法所需要的数据、指令、返回地址。
虚拟机栈里边存储的是栈帧。
栈帧里边内容包括：局部变量表、操作数栈、返回地址、动态连接 。
局部变量表（LocalVariableTable）：第一个位置存储的是this（类对象本身），之后存储的是方法的传参。
操作数栈（Code）：一大堆指令，程序就是依靠一条条指令执行实现的。
返回地址：记录返回地址，方法正常执行完后告诉虚拟机需要返回到哪里。
	比如：a方法里边执行了b方法，b的栈帧的返回地址就会记录a方法的地址，当b方法执行完了就会回到a方法对应的地方。（如果执行中发生异常，是去到异常处理器表）
动态连接：用来实现多态的。在类加载的时候记录当前具体是哪个实例的方法。
	比如：B、C类继承自A，B、C分别实现了A中的aa方法，B、C实现的aa方法是有区别的。aa方法中的动态连接就是为了记录当前实例到底是B还是C。

注意：虚拟机栈是有大小的（大小设置：-Xss），如果递归很深可能会导致虚拟机栈溢出（StackOverflowError）。

3、本地方法栈：存储当前线程所使用的native方法的信息。
当线程里边有调用native方法的时候，并不会在虚拟机栈中创建栈帧，而是在本地方法栈中创建。



虚拟机中的对象
虚拟机遇到一条new指令时：
1）检查加载
先执行相应的类加载过程。
2）分配内存
	指针碰撞
		接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。
		如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。
	空闲列表
		如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。
		选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
	并发安全
		除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。
	CAS机制
		解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；
		分配缓冲
		另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数 -XX:UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。
		TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。
		TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。
3）内存空间初始化
（注意不是构造方法）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
4）设置
接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。
5）对象初始化
在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。


虚拟机优化：逃逸分析
几乎所有的对象都是在堆中分配的，但是也有例外。

逃逸分析：可以在栈上创建对象
基本思想：对于线程私有的对象，将它打散分配在栈上而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。
逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，任何可以在多个线程之间共享的对象，一定都属于逃逸对象。
public void test(int x,inty ){
String x = “”;
User u = ….
….. 
}
User类型的对象u就没有逃逸出方法test。
public  User test(int x,inty ){
String x = “”;
User u = ….
….. 
return u;
}
User类型的对象u就逃逸出方法test。

如何启用栈上分配（+是开启，-是关闭）
-XX:+DoEscapeAnalysis：开启逃逸分析(默认打开)
-XX:+UseTLAB 开启本地线程分配缓冲（默认打开，只有开启了 本地线程分配缓冲才能使用栈上分配）

-XX:+EliminateAllocations：标量替换(默认打开，)

-XX:+PrintGC：开启GC日志


测试：a方法内创建一个对象，然后a方法循环调用一亿次。
关闭逃逸分析：会出现频繁gc，最终一亿次执行时长大概接近1秒（这一亿个对象都是在堆创建的，导致出现大量gc）
开启逃逸分析：一亿次执行时长大概7、8毫秒（栈上创建，只创建了一次对象，创建到了缓存中。重复执行a方法直接从缓存取了）

```





#### GC

##### 说说对垃圾回收器的理解。+3

```java
理解：自动将Java堆中不需要的对象进行回收
  
堆内存划分：（新生代:老年代 = 1:2）
新生代（PSYoungGen）
	Eden区:两个S区 = Eden:From:To = 8:1:1
老年代（ParOldGen）

堆内存分配策略：
1、对象优先在Eden分配，如果说Eden内存空间不足，就会发生Minor GC
2、大对象直接进入老年代。大对象：需要大量连续内存空间的对象，比如很长的字符串或大型数组。
3、长期存活的对象将进入老年代。默认15岁，-XX:MaxTenuringThreshold调整
	对象头会记录对象的年龄，当对象在S区中被复制一次，年龄就会+1岁。当达到最大年龄晋升到老年区。
4、动态对象年龄判定。
	虚拟机并不是永远地要求对象的年龄必须达到最大年龄才能晋升老年代，如果在S区中相同年龄所有对象大小的总和大于S区的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。 
5、空间分配担保。
	新生代中有大量的对象存活S区不够用了，当出现大量对象在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把S区无法容纳的对象直接进入老年代。
  
GC如何判断对象的存活？- 可达性分析算法。

GC如果进行回收的？- 复制回收算法；标记-清除算法；标记-整理算法。
```



##### 堆内存是怎么分配的？

```java
堆内存的划分：（新生代:老年代 = 1:2）
新生代（PSYoungGen）
	Eden区:两个S区 = Eden:From:To = 8:1:1
老年代（ParOldGen）

堆内存分配策略：
1、对象优先在Eden分配，如果说Eden内存空间不足，就会发生Minor GC
2、大对象直接进入老年代。大对象：需要大量连续内存空间的对象，比如很长的字符串或大型数组。
3、长期存活的对象将进入老年代。默认15岁，-XX:MaxTenuringThreshold调整
	对象头会记录对象的年龄，当对象在S区中被复制一次，年龄就会+1岁。当达到最大年龄晋升到老年区。
4、动态对象年龄判定。
	虚拟机并不是永远地要求对象的年龄必须达到最大年龄才能晋升老年代，如果在S区中相同年龄所有对象大小的总和大于S区的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。 
5、空间分配担保。
	新生代中有大量的对象存活S区不够用了，当出现大量对象在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把S区无法容纳的对象直接进入老年代。

GC策略：
新生代区内存不够，会触发Minor GC。
老年代区内存不够，会触发Full GC。
```



##### 新生代中3个区（Eden区 + 两个S区）为什么内存比例是8:1:1 ？

```java
1、在新生代区中绝大部分对象的生命都是很短暂的，也就是说并不需要按照1:1的比例来划分内存空间；
2、经长期研究测算出当内存使用超过98%以上时内存就应被minor gc回收一次。但是实际应用中如果真到98%才GC可能就来不及了，所以保险起见当内存使用到达90%的时候就gc，留10%的内存放存活的对象。
3、这预留下来的这10%的空间称为S区（有两个s区 s1 和 s0），S区是用来存储新生代GC后存活下来的对象，而GC算法使用的是复制回收算法。需要1:1的内存空间。也就是需要占用总内存的20%，留下了80%给Eden区。
4、每次GC范围是Eden区+一个S区。（比例是，eden:s1:s0=8:1:1=8:1:1）这里的eden区（80%）和其中的一个S区（10%） 合起来共占据90%，GC就是清理的他们，始终保持着其中一个S区是空留的，保证GC的时候复制存活的对象有个存储的地方。

8:1:1的优点：提高内存的利用率，只浪费了10%的内存。

如果存活的对象超过10%的内存怎么办？
空间担保：空间担保是老年代区，如果S区放不下了，会把多出来的部分放到老年代区。
```



##### GC如何判断对象是否需要回收？+2

```java
可达性分析算法：通过GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可达到，GC会回收它。
```



##### 什么对象可以作为GC Roots？

```java
1、虚拟机栈（栈帧中的本地变量表）中引用的对象。
2、方法区中类静态属性引用的对象。
3、方法区中常量引用的对象。
4、本地方法栈中JNI（即一般说的Native方法）引用的对象。

可达例子1：
static Obj a = new Obj(); //静态对象，是GC Roots
main(){
	Obj b = a;
	Obj c = b;
	Obj d = c;
	Obj e = a;
}

a -> b -> c -> d
  -> e
(b、c、d、e是可达的，方法执行完后，GC也不会回收它们)

可达例子2：
main(){
	Obj a = new Obj(); //GC Roots
	Obj b = a;
	Obj c = b;
}
(方法执行完之前，a、b、c都是可达的)

不可达例子：
Obj a = new Obj(); //不是GC Roots
main(){
	Obj b = a;
	Obj c = b;
}

a -> b -> c
(b、c是不可达的，方法执行完后，GC会回收它们)
```



##### GC如果进行回收的？

```java
垃圾回收算法：
  
复制回收算法：
将可用内存按容量划分为大小相等的两块区域，每次只使用其中的一块，当这一块的内存快用完了就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。

优点：实现简单，运行高效，不会出现内存碎片。
缺点：内存缩小了一半利用率低，需要内存复制。
使用场景：新生代区使用。

------------------------------------------------------------------

标记-清除算法：
分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
它的主要不足空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

优点：内存利用率百分百，无需内存复制。
缺点：会出现内存碎片。

------------------------------------------------------------------

标记-整理算法：
先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

优点：内存利用率百分百，不会出现内存碎片。
缺点：需要内存复制。
  

Stop The World现象：GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停。
1、可达性分析算法中枚举GC Roots会导致所有Java执行线程停顿。
2、完成GC后会切回原来的线程，由于切线程的过程也是耗时的，如果频繁GC频繁地切线程，也会造成卡顿。

GC收集器和我们GC调优的目标就是尽可能的减少STW的时间和次数。

单线程中的GC收集器：
Serial（新生代，复制回收算法）
SerialOld（老年代，标记整理算法）

多线程中的GC收集器：
ParNew（新生代，复制回收算法）- 搭配CMS垃圾回收器的首选 
ParallelScavenge（新生代，复制回收算法）
ParallelOld（老年代，标记整理算法）
CMS（老年代，标记清除算法）- 并行与并发收集器 - 互联网后端目前主流的垃圾回收器
G1（新生代 + 老年代）- 并行与并发收集器 - jdk1.7加入

除了G1是结合体之外，其他的垃圾回收器都是搭配使用的，都是新生代一个，老年代一个。

CMS
收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。

CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：
1、初始标记-短暂，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。 - 会暂停业务线程
2、并发标记-和用户的应用程序同时进行 - 并发标记，不会暂停业务线程
3、重新标记-短暂，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。- 会暂停业务线程
4、并发清除 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作。

浮动垃圾：由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。
```



#### 语法相关

1. final、finally、finalize()的区别。+3

2. 说说Java四种引用，以及用到的场景。+2

   ```JAVA
   四种引用：
   强引用
   
   软引用（SoftReference）：系统将要发生OOM之前，这些对象就会被回收。
   用途：例如为了让图片列表更快地显示，可以把它们直接加载到内存中，软引用它们。当系统内存不够即将OOM的时候，让系统释放掉这些图片的内存，保证程序的正常运行。大不了图片看不了而已，不至于闪退。
   
   弱引用（WeakReference）：只能生存到下一次垃圾回收之前，GC发生时不管内存够不够都会被回收。
   注意：软引用和弱引用，可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。
   实际运用（WeakHashMap、ThreadLocal）
   
   虚引用：幽灵引用，最弱，被垃圾回收的时候收到一个通知
   ```

   

3. 弱引用与强引用的区别 ，怎么判断一个弱引用被回收了 。

4. StringBuffer、StringBuilder的区别。+2

5. ==和equals和hashCode的区别。+2

6. String a="a"与String a = new String("a")的区别。+2

7. int、char、long各占多少字节数

8. int与integer的区别

9. 谈谈对java多态的理解。+2

10. 什么是内部类？内部类的作用

11. 泛型中extends和super的区别。

12. 说一下泛型原理，并举例说明。

13. Serializable 和Parcelable 的区别。+2

14. 父类的静态方法能否被子类重写

15. 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？

16. 静态内部类的设计意图

17. 成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用

18. 抽象类和接口区别

19. 抽象类的意义

20. 抽象类与接口的应用场景

21. 抽象类是否可以没有方法和属性？

22. 接口的意义

23. Java中String的了解

24. String为什么要设计成不可变的？

25. Object类的equal和hashCode方法重写，为什么？

    

    

    

#### 集合相关

1. Arraylist和Linklist的区别。+3

2. HashMap扩容条件中链表转红黑树的条件是什么？

3. HashMap扩容条件为什么要2的指数次幂，如果输入17会是多少容量？（跟hashcode有关，输入17得出结果是32）

4. CurrentHashMap 读写锁是如何实现的。（无hash冲突用CAS插入，有则用synchronize加锁插入。当链表长度大于8且数据长度>=64的时候会用红黑树代替链表）

5. List,Set,Map的区别

6. List和Map的实现方式以及存储方式

7. ConcurrentHashMap的实现原理

8. ArrayMap和HashMap的对比

9. HashTable实现原理

10. TreeMap具体实现

11. HashMap和HashTable的区别

12. HashMap与HashSet的区别

13. HashSet与HashMap怎么判断集合元素重复？

14. 二叉树的深度优先遍历和广度优先遍历的具体实现

15. 堆和树的区别

16. 什么是深拷贝和浅拷贝

17. 如何防止 Java 源码被反编译

    

#### 其他

1. 动态代理传入的参数有哪些？非接口类能实现动态代理吗？ASM的原理是什么？
2. utf-8编码中的中文占几个字节；int型几个字节？
3. 静态代理和动态代理的区别，什么场景使用？