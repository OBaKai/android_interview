### 一、内存泄漏检测 ✅

#### 1、线下 
##### ① LeakCanary

```java
Debug包开LeakCanary，检查是否有内存泄漏的情况发生
```

##### ② AS Profiler

```java
在测试阶段，对负责的模块进行自查
1、查看新开发的模块是否有内存异常情况（内存泄漏、内存抖动现象）
2、如果模块是功能性迭代，则需要比对内存在开发前与开发后变化是否健康。
```



  #### 2、线上

##### KOOM（计划取代LeakCanary，未实施）



### 二、内存监控 ✅

####  项目应用 

##### 轮询器

```java
项目启动后会启动一个轮询线程，每3分钟获取一下内存数据，其中包括 Java堆使用情况、线程数量、GC数量以及耗时等。
GC数量以及耗时有一定的性能，线上的话只在重点模块才会收集。
```

##### 数据上报策略

```java
触顶上报：虚拟内存使用超85%，是个非常危险的信号。GC会变得更加频发，容易造成OOM和卡顿。
内存不足上报：物理内存紧张 onTrimMemory/onLowMemory
 
上报次数记录：记录触发上报的次数以及时间，如果短时间内发生多次上报 或者 累计发生超过一定次数。
则开启hprof收集策略（hprof防止过大，会进行裁剪（基于Matrix-ResourceCanary的裁剪逻辑））。在下次上报的时候，主动导出hprof并上报。
```



#### 内存监控数据获取 

##### 1、虚拟内存

```java
大小限制：大多情况下为 4GB（32位）或512GB（64位）
当前状态：读取/proc/pid/status并解释VmSize字段
具体分析：读取/proc/pid/smaps，分析mapping及各个内存大小相关的字段
```

##### 2、Java堆（largeHeap可获取更大的堆空间）

```java
大小限制：Runtime.getRuntime().maxMemory()
当前使用：Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()
具体分析：到处进程的Hprof
  Dubug.dumpHprofData(String fileName)
	adb shell am dumpheap <pid> <file_path>
```

##### 3、FD数量（进程的fd是有最大限制的，fd耗尽也会发生OOM）

```java
大小限制：读取进程状态 /proc/pid/limits，并解释Max open files字段
当前状态：读取进程文件 /proc/pid/fd，计算文件数量
具体分析：遍历进程文件 /proc/pid/fd，并通过Os.readlink解释文件链接
```

##### 4、线程数量

```java
当前状态：读取进程状态 /proc/pid/status，并解释Threads字段
具体分析：调用Thread.getAllStackTraces() 获取当前所有线程的信息，包括线程名、调用栈及状态等
```

##### 5、Native内存

```java
通常说的Native内存是相对于Java堆而言的，Java堆区的内存有虚拟机代为申请和释放，Java层的业务代码无需关心。
Native内存主要说的是由业务动态申请的内存，一般是业务so库，业务代码是c/c++实现的，常用的方式就是调用 malloc函数申请内存，调用free释放内存。
这些内存的申请都需要合理的释放否则会导致内存不足。可结合Debug.getMemoryInfo()以及/proc/pid/smap文件来分析。

当前使用：读取nativePss，它是本进程内native层独占的内存和与其他进程共享内存的均摊的总和
具体分析：hook 业务每次malloc和free函数，记录每次内存的申请和释放，并获取到对应的堆栈，最后进行统计分析。
```

##### 6、GC次数以及耗时

```java
//6.0之前：
long allocCount = Debug.getGlobalAllocCount();
long allocSize = Debug.getGlobalAllocSize();
long gcCount = Debug.getGlobalGcInvocationCount();
//6.0之后：
Debug.getRuntimeStat("art.gc.gc-count");
Debug.getRuntimeStat("art.gc.gc-time");
Debug.getRuntimeStat("art.gc.blocking-gc-count");
Debug.getRuntimeStat("art.gc.blocking-gc-time");
```

##### 7、VSS/RSS/PSS/USS

| Item | 全称                  | 含义     | 等价                         |
| :--- | :-------------------- | :------- | :--------------------------- |
| USS  | Unique Set Size       | 物理内存 | 进程独占的内存               |
| PSS  | Proportional Set Size | 物理内存 | PSS= USS+ 按比例包含共享库   |
| RSS  | Resident Set Size     | 物理内存 | RSS= USS+ 包含共享库         |
| VSS  | Virtual Set Size      | 虚拟内存 | VSS= RSS+ 未分配实际物理内存 |

```java
概念=================================================
VSS：Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）
	一个进程总共可访问的地址空间，其大小还包括了可能不在RAM中的内存（VSS很少用于判断进程的真实内存使用量）
  
RSS：Resident Set Size 实际使用物理内存（包含共享库占用的内存）
  一个进程在RAM中真实存储的总内存。但是RSS还是可能会造成误导，因为它仅仅表示该进程所使用的所有共享库的大小，它不  管有多少个进程使用该共享库，该共享库仅被加载到内存一次。所以RSS并不能准确反映单进程的内存占用情况。 
  
PSS：Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）
  与RSS不同，它按比例表示使用的共享库，例如：如果有三个进程都使用了一个共享库，共占用了30页内存。那么PSS将认为每个进程分别占用该共享库10页的大小。 PSS是非常有用的数据，因为系统中所有进程的PSS都相加的话，就刚好反映了系统中的总共占用的内存。 而当一个进程被销毁之后， 其占用的共享库那部分比例的PSS，将会再次按比例分配给余下使用该库的进程。这样PSS可能会造成一点的误导，因为当一个进程被销毁后，PSS不能准确地表示返回给全局系统的内存。
  
USS：Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）
  一个进程所占用的私有内存。即该进程独占的内存（USS是非常非常有用的数据，因为它反映了运行一个特定进程真实的边际成本（增量成本）。当一个进程被销毁后，USS是真实返回给系统的内存。当进程中存在一个可疑的内存泄露时，USS是最佳观察数据）
  
一般来说内存占用大小有如下规律：VSS >= RSS >= PSS >= USS

  
命令查看=================================================
adb查看：adb shell procrank（根据不同进程的内存占用情况，从大到小的顺序排列的VSS/RSS/PSS/USS）
PID       Vss      Rss      Pss      Uss     Swap    PSwap    USwap    ZSwap  cmdline
19463  1876424K  176128K   49493K   35400K    8952K    4827K    4652K    1650K  system_server
19595  1282664K  163112K   41045K   28216K   12428K    8236K    8060K    2816K  com.android.systemui
25401  1258300K  121836K   28611K   18552K   27728K   23593K   23420K    8068K  com.android.launcher3
21342  1254156K  132608K   25632K   15012K   34224K   30012K   29836K   10263K  com.android.settings
...
  
  
获取方法=================================================
Debug.MemoryInfo memoryInfo = new Debug.MemoryInfo();
Debug.getMemoryInfo(memoryInfo);

api
dalvikPrivateDirty、dalvikSharedDirty、dalvikPss
nativePrivateDirty、nativeSharedDirty、nativePss
otherPrivateDirty、otherSharedDirty、otherPss
  
表示
dalvikPrivateDirty(USS) + dalivikSharedDirty == dalvikPSS
nativePrivateDirty + nativePrivateDirty == nativePSS
otherPrivateDirty + otherPrivateDirty == otherPSS

dalvik：是指dalvik所使用的内存。
native：是被native堆使用的内存。
other：是除dalvik和native使用的内存。但是具体是指什么呢？至少包括在C\C++分配的非堆内存，比如分配在栈上的内存。

private：是指私有的，非共享的。
share：是指共享的内存。
PSS：实际使用的物理内存（比例分配共享库占用的内存）
```



### 三、图片优化与监控 ✅

#### 1、统一图片加载库 
​    能够通过加载库帮我们统一加载、缓存图片，当系统内存紧张的时候，可以及时做一些处理。例如：释放图片下缓存，停止加载任务等。
​    例如：项目主要使用Glide。连svga加载也使用glide加载

#### 2、图片压缩

```java
色深："色彩的深度"，表示一个像素点用多少bit来存储色值。（数字图像参数）
位深：跟硬件相关的对象一律使用“位深”来描述（物理硬件参数）
例如：某张图片100*100 色深32位(ARGB_8888)，保存时位深度为24位
加载到内存中占大小：100 * 100 * (32 / 8)
存储到文件中占大小：100 * 100 * (24 / 8) * 压缩率

压缩方法有两种：1、质量压缩；2、尺寸压缩。
质量压缩：保持图片宽高以及占用内存不变的情况下，改变Bitmap的质量。（https://cloud.tencent.com/developer/article/1006307）
ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
//format：压缩格式，JPEG（有损）、PNG（无损，quality参数会不起作用）、WEBP（有损或无损，有损比JPEG更加省空间）
//quality：为0～100，0表示最小体积，100表示最高质量
bitmap.compress(Bitmap.CompressFormat.JPEG, quality, outputStream);

实现原理：
Java层函数 -> Native函数 -> Skia函数 -> 对应第三库函数（例如libjpeg）
（Skia在Android中提供了基本的画图和简单的编解码功能。可以挂接其他的第三方编码解码库或者硬件编解码库，例如libpng、libjpeg、libgif 等。bitmap.compress(Bitmap.CompressFormat.JPEG...)，实际会调用libjpeg.so动态库进行编码压缩）


哈夫曼算法：
文件中可能会出现五个值a,b,c,d,e，其二进制为
a. 1010
b. 1011
c. 1100
d. 1101
e. 1110
定长算法下最优（最前面的一位数字是 1，其实是浪费掉了）
a. 010
b. 011
c. 100
d. 101
e. 110

哈夫曼算法对定长算法进行了改进。给信息赋予权重，即为信息加权。
假设 a 占据了 60%，b 占据了 20%， c 占据了 20%，d,e 都是 0%
a:010  (60%)
b:011  (20%)
c:100  (20%)
d:101  (0%)
e:110  (0%)
在这种情况下，我们可以使用哈夫曼树算法再次优化为：
a:1
b:01
c:00
就是出现频率高的字母使用短码，对出现频率低的使用长码，不出现的直接就去掉。最后abcde的哈夫曼编码就对应：1 01 00

所以这个算法一个很重要的思路是必须知道每一个元素出现的权重，能够知道每一个元素的权重那么就能够根据权重动态生成一个最优的哈夫曼表。
怎么去获取每一个元素，对于图片就是每一个像素中argb的权重。只能去循环整个图片的像素信息，这无疑是非常消耗性能的。

Android在使用libjpeg，压缩默认使用的是 默认哈夫曼表，而不是 图像数据计算哈弗曼表。
//标志位
optimize_coding=FALSE //使用默认哈夫曼表
optimize_coding=TRUE  //使用图像数据计算哈弗曼表（比默认哈夫曼表体积缩小2倍）
Google在初期考虑到手机的性能瓶颈，计算图片权重这个阶段非常占用CPU资源的同时也非常耗时，因为此时需要计算图片所有像素 argb 的权重，这也是 Android 的图片压缩率对比 iOS 来说差了一些的原因之一。

从Android7.0 版本开始，optimize_code标示已经设置为了TRUE，也就是默认使用图像生成哈夫曼表。



尺寸压缩：改变Bitmap的宽高以及占用内存（https://cloud.tencent.com/developer/article/1006352?from=article.detail.1006307）
也叫重采样，放大图像称为上采样（upsamping），缩小图像称为下采样（downsampling）。主要讨论缩小图像。
Android中图片重采样提供了两种方法，一种是邻近采样（Nearest Neighbour Resampling），另一种是双线性采样（Bilinear Resampling）

邻近采样：inSampleSize（inDensity搭配inTargetDensity使用，效果跟inSampleSize是一样的）
BitmapFactory.Options options = new BitmapFactory.Options();
//设置取样大小。它的作用是：设置int类型后，假如设为4。则宽和高都为原来的1/4，宽高都减少了自然内存也降低了。（google推荐用2的倍数）
options.inSampleSize = 2; 
Bitmap compress = BitmapFactory.decodeFile("xxx.png", options);

邻近采样采用邻近点插值算法
邻近采样比较粗暴，采样率设置为2。那么就是两个像素选一个留下，另一个直接抛弃。
例如：每个像素红绿相间的图片。邻近采样为2的时候，图片直接变成绿色了。


双线性采样：Matrix
//方式一
Bitmap bitmap = BitmapFactory.decodeFile("xxx.png");
//双线性采样使用的是双线性內插值算法，参考源像素相应位置周围2x2个点的值，根据相对位置取对应的权重，经过计算之后得到目标图像。
//双线性内插值算法在图像的缩放处理中具有抗锯齿功能, 是最简单和常见的图像缩放算法.
Matrix matrix = new Matrix();
matrix.setScale(0.5f, 0.5f);
bm = Bitmap.createBitmap(bitmap, 0, 0, bit.getWidth(), bit.getHeight(), matrix, true);

//方式二，最终也是走方式一的
Bitmap bitmap = BitmapFactory.decodeFile("/sdcard/test.png");
Bitmap compress = Bitmap.createScaledBitmap(bitmap, bitmap.getWidth()/2, bitmap.getHeight()/2, true);

双线性采样 采用双线性内插值算法
参考了源像素相应位置周围2x2个点的值，根据相对位置取对应的权重，经过计算之后得到目标图像。
双线性内插值算法在图像的缩放处理中具有抗锯齿功能，是最简单和常见的图像缩放算法。
当对相邻2x2个像素点采用双线性內插值算法时，所得表面在邻域处是吻合的，但斜率不吻合，并且双线性内插值算法的平滑作用可能使得图像的细节产生退化，这种现象在上采样时尤其明显。

两个采样算法对比
邻近采样：最快的，效率最高；产生比较明显的锯齿（尤其是文字内容多的图片）；
双线性采样：抗锯齿。


双立方／双三次采样（Bicubic Resampling）
采用的是双立方／双三次插值算法
双立方／双三次插值算法更进一步参考了源像素某点周围4x4个像素。
Android中并没有原生支持，可以通过ffmpeg来支持，具体的实现在 libswscale/swscale.c 文件中：FFmpeg Scaler Documentation。
双立方/双三次插值算法经常用于图像或者视频的缩放，它能比双线性内插值算法保留更好的细节质量。
```



#### 3、图片监控（仅线下使用）

监控ImageView填充图片的合理性，参考代码：https://github.com/leavesCZY/ASM_Transform


    实现：1、Gradle Transform + ASM，在编译时将所有父类为ImageView的class，将其父类替换成我们的监控ImageView。
         2、xml里使用的不都是ImageView吗，为啥还能替换？？？
         原因：在layout xml解析的过程中，如果发现节点是ImageView，实例化的对象并不是ImageView，而是AppCompatImageView。
         所以我们替换AppCompatImageView的父类成监控ImageView，也就是将所有ImageView替换了。
         3、当我们当调用setImageDrawable、setImageBitmap等方法的时候发起检查（检查在IdleHandler中执行），检查图片是否过大、是否超过View大小等问题。
         4、一旦发现异常，就会在app内通知提醒开发人员。
    
    技术点：
    Gradle Transform：允许第三方以插件的形式，在打包成dex之前过程中操作class文件。
    我们插件只需要继承Transform类，去遍历所有.class文件的所有方法，然后进行修改再对源文件进行替换，即可以达到插入代码的目的。
    （每个Transform都是一个gradle task，编译器中的TaskManager将每个Transform串连起来，第一个Transform接收javac编译的结果，及已经拉取的第三方依赖（jar、aar），还有asset资源。这些编译的中间产物，在Transform组成的链条上流动，每个Transform节点可以对class进行处理再传递给下一个Transform。我们常见的混淆，Desugar等逻辑，它们的实现如今都是封装在一个个Transform中，而我们自定义的Transform，会插入到这个Transform链条的最前面。文章：https://www.jianshu.com/p/cf90c557b866）
    
    ASM：字节码操作框架，可用来动态生成字节码或者对现有的类进行增强。ASM可以直接生成二进制的class字节码，也可以在class被加载进虚拟机前动态改变其行为，比如方法执行前后插入代码，添加成员变量，修改父类，添加接口等等。（文章：https://www.jianshu.com/p/29e9b03c0796）



### 四、年份区分设备的性能 ✅

```java
facebook的device-year-class库区分设备性能。

根据不用设备的性能来制定策略。
低端机用户可以 关闭复杂的动画 或 "重功能" 或 使用565格式的图片或更小的缓存内存等等。
例如：
    跳过大内存的礼物动效的加载以及播放；
    动态点赞动效的跳过等负责动效的跳过；
    后台根据设备分开返回动效背景、动效头饰改为静态；
    图片加载设置RGB_565格式等。
```



### 五、对象优化 ✅

#### 1、大对象

统一的缓存管理，方便我们在系统内存紧张的时候，释放做缓存。

框架：ASimpleCache（https://github.com/yangfuhai/ASimpleCache）
支持缓存String、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象等。
还支持缓存时效，超过时间就会清除。



#### 2、小对象（提防内存抖动）

```java
避免频繁创建对象；有频繁创建对象的场景需引入对象池（享元模式）。
```



#### 3、单例缓存的对象优化

单例中的缓存的对象：是否可以降维到ViewModel；某个模块才会使用到的，退出模块记得置空对象。



### 六、其他优化

##### 1、多进程 
​    Zygote在fork子进程之后，会给它初始化一些资源。（一个空进程也会占用几MB+内存）
​    例如：Resources的sPreloadedDrawables、sPreloadedColorDrawables列表就是Zygote为我们预加载的。如果进程没有界面可以通过反射将这些资源释放。

##### 2、dex、so优化

适当降低dex、so的大小



### 七、兜底策略 ✅

##### 1、泄漏模块的兜底策略
在Activity走onDestory之后，将Activity添加到WeakRerefrence，延迟30s监控是否回收。
如果未回收则主动释放泄漏的Activity持有的ViewTree的背景图和ImageView图片，以及DrawingCache，监听器等等资源。
（Fragment同样也带有这个机制，但是默认是关闭的，因为大部分的Fragment都是跟Activity共存亡的，少部分存在替换场景这些场景的Fragment才需要开启。）

##### 2、OOM兜底策略：try/catch
捕获到OOM的时候，主动清除缓存、降低Bitmap format、关闭部分动效等

##### 3、物理内存不住的兜底策略
使用onTrimMemory/onLowMemory

收到回调的时候，主动清除缓存、降低Bitmap format、关闭部分动效等



### 八、数值量化内存优化成果 

```java
1、待机的情况下内存占用率
2、重点模块的内存占用率
对比优化前后的内存占用率

3、OOM率 - bugly上报oom次数的统计
统计优化前后的OOM率

4、GC次数以及耗时
统计优化前后的GC次数与耗时情况
```



### 九、内存问题

#### 1、内存抖动

```java
原因：频繁GC引起。
现象：内存波动图形呈锯齿状；应用出现卡顿；出现内存碎片，容易引发OOM。
Dalvik虚拟机尤为明显。ART虚拟机做了大量优化，内存分配和GC效率相比提升了5~10倍。出现内存抖动的概率会小很多。

常见案例：
1、字符串使用加号拼接（StringBuilder替代。初始化时设置容量，减少StringBuilder的扩容。）
2、资源复用（使用全局缓存池，以重用频繁申请和释放的对象。结束后需手动释放池中的对象。）
3、减少不合理的对象创建（onDraw、getView中创建的对象尽量进行复用；避免在循环中不断创建局部变量。）
4、使用合理的数据结构（SparseArray类族、ArrayMap来替代 HashMap）
```

#### 2、内存泄漏

```java
原因：对象被持有导致无法释放 或 不能按照对象正常的生命周期进行释放。
现象：可用内存减少，容易引发OOM。
分析工具：
    MemoryProfiler（as自带的）
    LeakCanary（dump的分析会影响到主进程，整个进程会卡住）
    Koom（fork dump，能在dump分析的时候而不影响到进程）
```

#### 3、OOM

```java
原因：在内存中，无法申请到一块对应大小的连续内存导致的。
现象：程序抛出OOM异常。

OOM类型：
java.lang.OutOfMemoryError: Could not allocate JNI Env
fd申请失败：进程的fd耗尽（一个进程限制是有fd个数限制的，一般是2、3万，不过有少部分设备会限制到1024）
查看fd限制数量：adb shell ulimit -a
当前进程占用fd数：lsof | grep <进程号> | wc -l （需root）
watch -n 2 'adb shell su lsof | grep <进程号> | wc -l'（watch命令定时监控）
当前进程fd信息：ls -la proc/{pid}/fd/

Android Fd泄漏问题分析文章：https://www.jianshu.com/p/befd4b86cc42


java.lang.OutOfMemoryError: pthread_create (1040KB stack) failed: Try again
开启线程失败：虚拟内存不足，无法开启线程（启动一个线程需要先分配1040KB（1024 + 8 + 8）虚拟内存，再去启动的）

创建线程源码与OOM分析文章：https://blog.csdn.net/Tencent_Bugly/article/details/78542324
```

#### 4、Native内存泄漏（待学习）

#### 5、物理内存不足

```java
设备物理内存告急会通知各个进程（onTrimMemory/onLowMemory），这类的问题难以分析以及定位。并且整个系统可能会出现卡死甚至重启，ANR频发（随便找个进程背锅）。
如果遇到这种情况，老老实实给系统解解压（释放缓存、在后台的话可以自销毁等）。
  
维护良好的系统环境，人人有责！！！
```



### 十、学习记录

学习目标：

```java
Matrix-ResourceCanary 重点学习Hprof的裁剪，加深对Hprof文件的了解。✅
LeakCanary 重点学习各个组件泄漏的检测，学习它的一些检测思想。✅
KOOM 重点学习它阀门检测机制、线程泄漏、Native堆泄漏。
```



#### 0、Hprof文件 

```java
Hprof是由J2SE支持的一种二进制堆转储格式，Hprof文件保存了当前java堆上所有的内存使用信息，能够完整的反映虚拟机当前的内存状态。

Hprof文件基本数据类型为：u1、u2、u4、u8，分别表示1byte、2byte、4byte、8byte的内容
Hprof文件组成：由一个FixedHead 以及 多个Record组成。
	FixedHead包括：
  	Version（u1，格式名称及版本）
  	ID size（u4，字符串、对象、堆栈等信息的id的长度，很多record的具体信息需要通过id来查找）
    Time（u8，时间戳）
  Record包括：
  	Tag（u1，Record类型）
    Time（u4，时间戳）
    Length（u4，Body字节长度）
    Body（u4，Record内容）

enum HprofTag { //Record Tag类型
  HPROF_TAG_STRING = 0x01,            // 字符串（保存着所有的字符串，在解析时可通过索引id引用）
  HPROF_TAG_LOAD_CLASS = 0x02,        // 类（包括类内部的变量布局，父类的信息等等）
  HPROF_TAG_UNLOAD_CLASS = 0x03,
  HPROF_TAG_STACK_FRAME = 0x04,        // 栈帧
  HPROF_TAG_STACK_TRACE = 0x05,        // 堆栈
  ...
  HPROF_TAG_HEAP_DUMP = 0x0C,            // 堆（内存占用与对象引用的详细信息）
  HPROF_TAG_HEAP_DUMP_SEGMENT = 0x1C,
  HPROF_TAG_HEAP_DUMP_END = 0x2C,
  ...
};
每一个Tag及其对应的内容可参考HPROF Agent（上边有链接）。
比如String record：Tag为0x01，那么当前record就是字符串，第一部分信息是字符串ID，第二部分就是字符串的内容。

堆信息，即Tag为 HPROF_TAG_HEAP_DUMP 或 HPROF_TAG_HEAP_DUMP_SEGMENT 时
那么Body由一系列子Record组成，这些子Record同样使用Tag来区分：
enum HprofHeapTag { //堆Record的子Record Tag类型
  HPROF_ROOT_UNKNOWN = 0xFF,
  HPROF_ROOT_JNI_GLOBAL = 0x01,        // native 变量
  HPROF_ROOT_JNI_LOCAL = 0x02,
  ...
  HPROF_CLASS_DUMP = 0x20,            // 类
  HPROF_INSTANCE_DUMP = 0x21,         // 实例对象
  HPROF_OBJECT_ARRAY_DUMP = 0x22,     // 对象数组
  HPROF_PRIMITIVE_ARRAY_DUMP = 0x23,  // 基础类型数组

  // Android.（Android增加了额外的9个）
  HPROF_HEAP_DUMP_INFO = 0xfe,
  HPROF_ROOT_INTERNED_STRING = 0x89,
  HPROF_ROOT_FINALIZING = 0x8a,  // Obsolete.
  HPROF_ROOT_DEBUGGER = 0x8b,
  HPROF_ROOT_REFERENCE_CLEANUP = 0x8c,  // Obsolete.
  HPROF_ROOT_VM_INTERNAL = 0x8d,
  HPROF_ROOT_JNI_MONITOR = 0x8e,
  HPROF_UNREACHABLE = 0x90,  // Obsolete.
  HPROF_PRIMITIVE_ARRAY_NODATA_DUMP = 0xc3,  // Obsolete.
};
其中比较重要的是HPROF_HEAP_DUMP_INFO。
Android上将java堆分为Heap-App、Heap-Image、Heap-Zygote三块，这个Tag的作用是切换当前的堆，该Tag后面紧跟着一个u4的堆id 和 一个堆名称id
比如出现一个HPROF_HEAP_DUMP_INFO Record，且该Record表示Heap-Image，那么表示后续所有Record中的类、对象、GCRoot对象均在Heap-Image中存储，直到下一个HPROF_HEAP_DUMP_INFO出现为止。


使用AS Profiler工具分析Hprof文件：
View Heap
1、app heap：当前APP从堆中分配的内存
2、image heap：系统启动映像，包含启动期间预加载的类。 此处的分配保证绝不会移动或消失
3、zygote heap：zygote是所有APP进程的母进程，linux的进程使用COW技术，所有的APP共享zygote的内存空间，因此堆的话也继承了，并且zygote的这些空间不允许写入，为了加快java的启动和运行速度，zygote在启动时预加载了许多资源和代码，这样可以提高APP的运行速率.
源码

Classes：该堆上的Class对象数
Leaks：该堆上泄漏的数量！！！！！（需要重点关注有这个标记类）
Count：该堆上对象数

Depth：从gc roots到选中的当前对象的引用链最短长度
Allcoations：该类的对象数量
Native Size：native对象的内存大小
Shallow Size：对象本身占用的内存，不包括它引用的其他实例
  [类定义] + 父类fields所占空间 + 自身fields所占空间 + [alignment]
Retained Size：当实例A被回收时, 可以同时被回收的实例的Shallow Size之和。
  所以进行内存分析时，应该重点关注Retained Size较大的实例; 或者可以通过Retained Size判断出某A实例内部使用的实例是否被其他实例引用。
Reference：eference里面主要是类的引用关系，可以通过引用关系，一层一层的查看类是如何泄漏的。
```

文章参考

android中hprof文件分析：https://blog.csdn.net/u013309870/article/details/115482411
HPROF Agent：http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html#mozTocId848088



#### 1、Matrix - ResourceCanary 

功能：修复内存泄漏；检测内存泄漏；抓取Hprof并对其进行裁剪。

##### ① 内存泄漏修复功能

```java
使用：需要主动调用 ResourcePlugin#activityLeakFixer
分析：监听registerActivityLifecycleCallbacks，在onActivityDestroyed的时候执行这几个方法
1、ActivityLeakFixer.fixInputMethodManagerLeak(activity); 
//解决InputMethodManager持有view引发的内存泄漏

2、ActivityLeakFixer.unbindDrawables(activity);
//将Activity内所有的View，Listener、Drawable 等可能存在的引用关系切断
 public static void unbindDrawables(Activity ui) {
        final long startTick = System.currentTimeMillis();
        if (ui != null && ui.getWindow() != null && ui.getWindow().peekDecorView() != null) {
            final View viewRoot = ui.getWindow().peekDecorView().getRootView();
            try {
                unbindDrawablesAndRecycle(viewRoot);
                if (viewRoot instanceof ViewGroup) ((ViewGroup) viewRoot).removeAllViews();
            } catch (Throwable thr) { ... }
        } 
   			...
    }

  private static void unbindDrawablesAndRecycle(View view) {
        ...
        recycleView(view); //将大量Listener置为空
        //根据不用的View，进行不用的处理
        if (view instanceof ImageView) { //Drawable置为空
            recycleImageView((ImageView) view);
        }
        if (view instanceof TextView) { //Drawable置为空，如果是EditText，还执行fixTextWatcherLeak
            recycleTextView((TextView) view);
        }
        ... //好多View的处理
        if (view instanceof ViewGroup) { //继续寻找子View继续执行unbindDrawablesAndRecycle
            recycleViewGroup((ViewGroup) view);
        }
    }

3、ActivityLeakFixer.fixViewLocationHolderLeakApi28(activity);
//修复Android P中，ViewGroup$ViewLocationHolder$mRoot的内存泄漏
```

##### ② 内存泄漏监控

```java
逻辑：开启定时轮询监控器，对走了onDestroye的Activity进行监控。
     将该Activity对象加入设置为弱引用，轮询发现该Activity未被回收，多次发现之后认为该Activity泄漏了。
     执行导出hprof以及上报操作。

源码分析：
Activity泄漏监控逻辑：
ActivityRefWatcher#start（开始监控）
   1、注册ActivityLifecycleCallbacks
   2、执行scheduleDetectProcedure()：开启一个定时轮询的任务（mScanDestroyedActivitiesTask）
ActivityLifecycleCallbacks#onActivityDestroyed 
  -> ActivityRefWatcher#pushDestroyedActivityInfo
  	 1、创建DestroyedActivityInfo对象（会生产该Activity的uuid，并且弱引用该Activity）
     2、将DestroyedActivityInfo对象缓存到mDestroyedActivityInfos容器
  -> 延迟2s执行 ActivityRefWatcher#triggerGc（主动触发一次GC）

 定时轮询任务 mScanDestroyedActivitiesTask#execute
  -> ActivityRefWatcher#triggerGc（主动触发一次GC）
  -> 遍历mDestroyedActivityInfos容器
  	 1、DestroyedActivityInfo对象的 Activity弱引用==null，就移除自身（因为该Activity不泄露）
     2、DestroyedActivityInfo对象的 Activity弱引用!=null, 对象内的mDetectedCount属性自增1
     3、DestroyedActivityInfo对象的 mDetectedCount 没到临界次数，ActivityRefWatcher#triggerGc
     4、DestroyedActivityInfo对象的 mDetectedCount 到的临界次数（发现Activity泄漏了）
  			就移除该自身对象，并且执行 mLeakProcessor#process 导出hprof
  
 Hprof导出逻辑：
  -> mLeakProcessor#process（BaseLeakProcessor是根据开发者配置的DumpMode参数来创建）
  	 配置AUTO_DUMP就会创建AutoDumpProcessor（直接在该进程导出hprof）
     配置FORK_DUMP就会创建ForkDumpProcessor（fork子进程导出hprof）
  	 配置...
  -> ForkDumpProcessor#process（以FORK_DUMP配置为例）
  	 -> MemoryUtil#dump -> memory_utils.cpp#forkDump -> fork出子进程，然后执行dump hprof
     -> getWatcher().markPublished -> 记录该Activity为已上报（防止多次上报）
     -> getHeapDumpHandler().process -> CanaryWorkerService#shrinkHprofAndReport（对hprof进行裁剪跟上报）
```

##### ③ hprof裁剪

```java
CanaryWorkerService#shrinkHprofAndReport（JobScheduler方式）-> CanaryWorkerService#onHandleWork -> CanaryWorkerService#doShrinkHprofAndReport -> 
  	裁剪：new HprofBufferShrinker().shrink(hprofFile, shrinkedHProfFile);
		上报：CanaryResultService.reportHprofResult(...);

吐槽一下：官方说的10倍以上的瘦身效果。是相对android8.0-而言的。
  	     android8.0+之后Bitmap像素数据都放native了，瘦身效果微乎其微。

裁剪逻辑：
1、读取 Hprof 文件
2、记录 Bitmap 和 String 类信息
3、移除 Bitmap buffer 和 String value 之外的基础类型数组
4、将同一张图片的 Bitmap buffer 指向同一个 buffer id，移除重复的 Bitmap buffer
5、其它数据原封不动地输出到新文件中
注意：Bitmap的mBuffer字段在android8.0被移除了，所以无法分析android8.0的设备的重复Bitmap。
  
//HprofReader负责读取数据，然后交给HprofVisitor去处理
public void shrink(File hprofIn, File hprofOut) throws IOException {
    final HprofReader reader = new HprofReader(new BufferedInputStream(is));
    //第一次读取
    //HprofInfoCollectVisitor作用：记录Bitmap和String类信息
    reader.accept(new HprofInfoCollectVisitor());
    is.getChannel().position(0);  //让指针回到0，准备第二次读取
    
    //第二次读取
    //HprofKeptBufferCollectVisitor作用：记录所有String对象的valueID 以及 Bitmap对象的BufferID与其对应的数组本身
    //接着分析所有Bitmap对象的buffer数组，如果其MD5相等，说明是同一张图片，就将这些重复的bufferID映射起来，以便之后将它们指向同一个buffer数组，删除其它重复的数组
    reader.accept(new HprofKeptBufferCollectVisitor());
    is.getChannel().position(0); //让指针回到0，准备第三次读取
   
    //第三次读取
    //HprofBufferShrinkVisitor作用：读取到数据之后就由 HprofWriter 输出到新的文件
    //在写入之前，会由HprofBufferShrinkVisitor进行一些特殊操作
    //输出Bitmap对象需要将相同的Bitmap数组指向同一个bufferID，以便接下来剔除重复的buffer数据
    //基础类型数组，如果不是Bitmap中的mBuffer字段 或 String中的value字段，则不写入到新文件中
    reader.accept(new HprofBufferShrinkVisitor(new HprofWriter(os)));
}
```



#### 2、LeakCanary2.0

##### ① 自动初始化

```java
AppWatcherInstaller继承自ContentProvider，ContentProvider在Application执行onCreate之前就会被安装，然后就会执行ContentProvider#onCreate。
AppWatcher.manualInstall(application) 方法就是在ContentProvider#onCreate里边执行的。
```

##### ② Activity泄漏监控

```java
AppWatcher#appDefaultWatchers -> ActivityWatcher(xx, xxx)
  -> ActivityWatcher#install
     1、注册 ActivityLifecycleCallbacks 监听
	   2、在 onActivityDestroyed 回调中，对avtivity对象进行监控（ObjectWatcher#watch）。让ObjectWatcher来进行对象回收的监控。

  
ObjectWatcher有两个集合：
1） private val watchedObjects = mutableMapOf<String, KeyedWeakReference>() 用来存放要观察对象的key和弱引用,代码会为每个观察的对象生成一个唯一的key和弱应用

2）private val queue = ReferenceQueue<Any>()
这个队列 和 watchedObjects联合使用。
当弱引用中的对象被回收后，这个弱引用会被放到这个队列中。
换句话说就是只要存在这个队列中弱引用，就代表这个弱引用中所包含的对象被回收了。

 
ObjectWatcher#watch分析：
1、先移除watchedObjects 和 queue 集合里面已经回收对象的弱引用。

2、通过uuid为当前观察的对象生成一个唯一的key,并把对象用弱应用包起来，放到watchedObjects 这个集合中，同时把queue 和弱应用关联起来。

3、checkRetainedExecutor.execute {moveToRetained(key) }
这里是个延迟任务，延迟五秒后再次执行1操作，这个期间对象可能已经被回收了，所以需要再次移除一次。

4、执行了3操作后，就可以通过watchedObjects 集合找到没有被回收的对象了。这时候就可以获取到没有被回收的对象的个数，大于0，进行一次gc操作（Runtime.getRuntime().gc()，源码上注释这个操作比system.gc()更可能触发gc操作）。

5、再次获取未被回收的个数,这一步会有几个判断条件
 1）如果个数小于5，不做操作等待5秒再次进行检查未回收的个数，一直循环，直到大于等于5个或者等于0个，为了防止频发回收堆造成卡顿。
 2）大于5个后，如果处于debug模式，会再等20秒，再次执行4操作。防止debug模式会减慢回收
 3）距离上次堆栈分析是否大于等于1分钟，如果没有超过一分钟，也需要再次延迟（1分钟-当前距离上次的时间）再次循环4操作

6、如果上面的条件都符合了，就可以开始进行堆栈的分析了
 1）获取到内容文件 Debug.dumpHprofData(heapDumpFile.absolutePath)
 2）objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)该操作是去掉以前已经分析过的对象，也就是去除掉之前的没有回收掉的对象，不在本次分析范围内
 3）HeapAnalyzerService开启IntentService服务进行分析（HAHA库进行分析hprof文件）
 4）把结果插入数据库（泄漏区分了应用本身的内存泄漏和类库的内存泄漏），并且发送通知
```



##### ③ Fragment、ViewModel、RootView、Service泄漏监控

```java
对象泄漏监控的通用方法：发现目标对象在没有利用价值的时候，拿到目标对象加入到泄漏监控里边。

Fragment & ViewModel 泄漏监控
AppWatcher#appDefaultWatchers -> FragmentAndViewModelWatcher(xx, xxx)
  -> FragmentAndViewModelWatcher#install
		 1、注册 ActivityLifecycleCallbacks 监听
     2、在 onActivityCreated 回调的时候，执行多个Watcher
     		AndroidOFragmentDestroyWatcher
     		AndroidXFragmentDestroyWatcher
     		AndroidSupportFragmentDestroyWatcher
  
  -> 以 AndroidXFragmentDestroyWatcher 为例 -> AndroidXFragmentDestroyWatcher#invoke
     1、通过activity对象获取FragmentManager，然后注册 FragmentLifecycleCallbacks 监听
     2、执行ViewModelClearedWatcher#install -> 目标是activity对象
     3、在 onFragmentCreated 回调的时候，执行ViewModelClearedWatcher#install -> 目标是fragment对象
     4、在 onFragmentViewDestroyed / onFragmentDestroyed 的时候（fragment到了没有利用价值的时候，加入泄漏监控）
  	 	  onFragmentViewDestroyed 对 fragment.view 进行监控（ObjectWatcher#watch）
        onFragmentDestroyed 对 fragment 进行监控（ObjectWatcher#watch）
  
   -> ViewModelClearedWatcher#install(storeOwner: ViewModelStoreOwner, ...)
  分别传入了activity对象、fragment对象（因为在AndroidX，Activity、Fragment都实现了ViewModelStoreOwner接口）
     1、通过ViewModelProvider创建一个ViewModelClearedWatcher的ViewModel对象，并将它和Activity或Fragment关联起来
     当ViewModel回收时会调用ViewModel#onCleared，所以走到ViewModelClearedWatcher#onCleared方法中
     2、ViewModelClearedWatcher在构造函数中反射 ViewModelStore#mMap 获取到存放ViewModel的容器
     3、ViewModelClearedWatcher#onCleared 通过获取容器中的ViewModel对象，对它们加入泄漏监控
  
  
  
RootView 泄漏监控
AppWatcher#appDefaultWatchers -> RootViewWatcher(xx, xxx) 
-> RootViewWatcher#install
   1、创建OnRootViewAddedListener（它继承自OnRootViewsChangedListener）
   2、注册这个OnRootViewAddedListener监听器
-> OnRootViewAddedListener（当View添加到Window的时候就会回调）
   1、判断rootView类型，看是否需要监控
   2、对rootView执行 View#addOnAttachStateChangeListener，关注view的依附状态
   3、当View回调onViewDetachedFromWindow的时候，将view对象加入泄漏监控
  
RootViewsSpy#install
  1、hook WindowManagerGlobal#mViews（ArrayList<View> mViews），并且代理其mViews属性，监听mViews的add、remove方法。
  2、当有View从mViews添加、移除的时候，通知所有的 OnRootViewsChangedListener#onRootViewsChanged
  
  
Service 泄漏监控
AppWatcher#appDefaultWatchers -> ServiceWatcher(xx, xxx)
-> ServiceWatcher#install
  1、hook ActivityThread#mServices属性（ArrayMap<IBinder, Service>）
  2、hook ActivityThread#mH，设置Callback，接收Service销毁的msg（为了切线程组件的生命周期都是走mH的）
    当接收Service销毁的msg，从msg数据中获取token，然后通过token从 mServices 获取Serivce对象
    将Service对象弱引用后丢给servicesToBeDestroyed容器（WeakHashMap<IBinder, WeakReference<Service>>）
  3、hook ActivityManager（IActivityManager），代理所有这些binder接口
    只关注 serviceDoneExecuting 方法，当发现执行了 serviceDoneExecuting 方法
    判断servicesToBeDestroyed里边是否还存在Service对象，如果存在将Service对象加入泄漏监控
  （可以理解为 Service销毁的msg：Service#onDestroy前；serviceDoneExecuting：Service#onDestroy后。）
```

##### ④ HAHA分析hprof文件（待学习）

文章参考：
LeakCanary2.0版本原理简单查看：https://www.jianshu.com/p/850c974e984b
LeakCanary原理分析：https://zhuanlan.zhihu.com/p/57425510
LeakCanary 原理剖析：https://cloud.tencent.com/developer/article/1675655



#### 3、KOOM 2.0

##### ① 基本知识

##### ② Java Heap泄漏监控

##### ③ Thread 泄漏监控

##### ④ Native Heap泄漏监控

##### ⑤ Hprof裁剪



### 十一、很棒的内存优化文章推荐

```java
全民 K 歌内存篇
1线上监控与综合治理 https://mp.weixin.qq.com/s/KWaueLMZwwLSjGGJya6qFA
2虚拟内存浅析 https://mp.weixin.qq.com/s/pbLLLCXlkz6gp9ps65rMYA
3native 内存分析与监控 https://mp.weixin.qq.com/s/0cF5Q6_LXrkLAdjkXIwrVQ

抖音
Java 内存优化篇 https://blog.csdn.net/ByteDanceTech/article/details/111503373
Java OOM优化之NativeBitmap方案 https://blog.csdn.net/ByteDanceTech/article/details/124487103

微信
微信 Android 终端内存优化实践 https://cloud.tencent.com/developer/article/1362381

极客时间 Android 开发高手课
https://time.geekbang.org/column/intro/100021101?tab=catalog  

bugly Android内存优化总结&实践 
https://cloud.tencent.com/developer/article/1071719?from=article.detail.1030855

Matrix相关文章
内存泄漏监控源码分析 https://juejin.cn/post/6854573218179579912
Hprof文件分析 https://juejin.cn/post/6854573208520097799
I/O监控及原理解析 https://juejin.cn/post/6895253983767003144#heading-5

QQ音乐
Android 中图片压缩分析（上） https://cloud.tencent.com/developer/article/1006307
Android 中图片压缩分析（下） https://cloud.tencent.com/developer/article/1006352

Bitmap 位图内存的演进流程 https://sharrychoo.github.io/blog/android-source/bitmap-memory-evolution

Android内存优化分析总结 https://juejin.cn/post/7123452813656457253
```
