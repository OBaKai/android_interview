计算机最主要的两个部件CPU和存储器
寄存器：（在CPU里边）是用来暂存数据的（可以是字符串、可以是数值、也可以是一个地址，它可以是各种类型的数据）。
存储器：一般指内存，硬盘一般叫外部存储器。
寄存器的速度比主存储器的速度要快很多，由于寄存器的容量有限，所以将不需要操作的数据存放在主存储器中，主存储器中的数据必须放入寄存器材能够进行操作。

存储单元：在内存中用来存放数据的，一个存储单元是8位（一个字节）
存储单元地址：每个存储单元都有对应一个地址（有了地址CPU才能通过地址找到这个单元读取出里边的数据）



arm处理器运行模式：7种运行模式。分为两个种类，普通模式：usr，其他都是特权模式。
1、用户（usr）：正常程序执行状态
2、系统（sys）：运行具体特权的操作系统任务
3、快速中断（fiq）：用于高速数据传输或通道处理，当发生快速中断会进入此模式
4、外部中断（irq）：用于通用的中断处理，当发生外部中断会进入此模式
5、特权（svc）：操作系统使用的保护模式，在系统复位或软件中断指令SWI时进入
6、中止（abt）：用于虚拟存储及存储保护，当数据或指令预取中止时进入此模式
7、未定义指令中止（und）：用于支持硬件协处理器的软件仿真，当未定义指令执行时进入该模式

在特权模式下程序可以访问所有的系统资源。
非特权模式和特权模式之间的区别在于有些操作只能在特权模式下才被允许，例如直接改变模式和中断使能等。
而且为了保证数据安全，一般MMU会对地址空间进行划分，只有特权模式才能访问所有的地址空间。
而用户模式如果需要访问硬件，必须切换到特权模式下，才允许访问硬件。




arm寄存器：共有37个寄存器。其中31个为通用寄存器（包括pc），6个状态寄存器（1个当前状态寄存器，5个备份状态寄存器）
寄存器分类：
	通用寄存器：用来暂存数据。通用寄存器共16个，分别是R0-R15
		通用寄存器分组：
			未分组寄存器（R0-R7，在所有的运行模式下都是指向同一个物理寄存器，它们未被系统用作特殊的用途）
			分组寄存器（R8-R14，每次访问的物理寄存器地址取决于CPU当前的工作模式）
			程序计数器（R15，专用名字pc，用来存储CPU执行的下一条指令指针，也是对应一个物理寄存器）

		不是只有16个吗，为什么会有31个出来？因为分组寄存器在不同运行模式下有不同的寄存器
		R8-R12（共10个）：fiq模式时访问寄存器R8_fiq-R12_fiq，其他模式都是R8-R12
		R13-R14（共12个）：usr和system模式共用R13-R14，其他模式都有自己的R13-R14，比如R13_fiq-R14_fiq
			R13在arm指令中常用作堆栈指针SP，所以我们在自己初始化的时候一般都要初始化每种模式下的R13，使其指向该运行模式的栈空间。
			R14称为子程序链接寄存器LR，即在调用子程序的时候，可以将当前的程序地址存入LR寄存器，这样就方便了函数的返回。它有两个特殊功能，一种是每一种模式下都可以用于保存函数的返回地址，通常LR会配合BL和BLX来使用；另外就是异常处理后的返回地址，如中断。

	状态寄存器：用来设计CPU工作模式和工作状态
		CPSR（当前状态寄存器）

		SPSR（5个备份状态寄存器）
		除usr、sys外，对应用于异常保护的CPSR的备份，异常时，保存CPSR值，异常退出时，将该值恢复到CPSR，以保证程序的正常运行，每一中异常运行模式（除usr和sys）有各自的物理寄存器。


usr模式下寄存器的使用
	传递参数与返回值：R0-R3（如何传参超过4个，那么将多出来 的参数存储在堆栈中）
	保存栈顶地址：R13/SP
	保存函数返回地址：R14/LR
	程序计数器：R15（pc）
	状态寄存器：CPSR

arm处理器指令集：
arm指令集（执行32位对齐指令的arm指令）
thumb指令集（执行16位对齐的thumb指令）
arm64指令集



arm指令集

1、跳转指令
	B 无条件跳转
	BL 带链接的无条件跳转
	BX 带状态切换的无条件跳转
	BLX 带链接和状态切换的无条件跳转
	B loc_地址
	BNE（!=）、BEQ（==）

2、存储器与寄存器交互数据指令（核心）
	单寄存器操作：
	LDR 读！！！从存储器中数据读到一个寄存器（方向：<- 从右到左执行）
		例如：LDR R8, [R9, #04]
		解析：从R9+#04这个存储单元地址中读出数据读到寄存器R8（[]表示一个存储单元地址）
	STR 写！！！将寄存器的数据写到存储器（方向：-> 从左到右执行）
		例如：STR R8, [R9, #04]
		解析：将寄存器R8的数据写到R9+#04这个存储单元里边

	多寄存器操作：
	LDM 将存储器的数据加载到一个寄存器列表（方向：->）
		例如：LDR R0, {R1-R3}
		解析：将R0指向的单元地址的数据依次加载到R1、R2、R3寄存器
	STM 将一个寄存器列表的数据存储到存储器（方向：<-）

	PUSH 将寄存器值推入堆栈
	POP 将堆栈值推出到寄存器

	SWP 将寄存器与存储器之间的数据进行交换
		例如：SWP R1, R1 [R0]
		解析：将R1寄存器与R0指向的存储单元地址的数据进行交换

3、数据传送指令
	MOV：将立即数或寄存器的数据传送到目标寄存器
		例如：MOV R0, #8
		解析：相当于R0=8
		注意：MOV R0, #0（这个指令也常用于清空寄存器中的数据）

4、数据算术运算指令（方向：<-）
	ADD
	SUB
	MUL
	DIV
	有符号，无符号运算；带进位运算

5、数据逻辑运算指令
	AND 与
	ORR 或
	EOR 异或
	位移：实质是乘、除，类似于小数点移位，但相反。（小数点左移，数变小，右移变大）
	LSL 逻辑左移（方向 <-）
	LSR 逻辑右移（方向 <-）
		例如：LSL R0,R1, #2
		解析：R0=R1*4（左移2位相当于乘2的2次方）

6、比较指令
	CMP 用于比较，用于把寄存器内容和另外一个寄存器内容或者立即数进行减法比较。不存储结果，但是会更改标志寄存器
	如果标志寄存器中Z标志位不等于0，跳转到BNE后标记处（!=）
	如果标志寄存器中Z标志位等于0，跳转到BEQ后标记处（==）
	例如：
	CMP R0, #8
	BNE loc_8888 
	... //省略很多指令
	loc_8888
	... //省略很多指令

	解析：
	if(R0!=8)
		走loc_8888
	else
		继续执行


7、其他指令
	SWT 协处理器指令（切换用户模式）
	DCB 伪指令


寄存器寻址方式
立即寻址：MOV R0, #8（R0=8 直接赋值立即数）
寄存器寻址：MOV R0,R1（R0=R1 将寄存器中的地址赋值给另外一个寄存器）
寄存器位移寻址：MOV R0,R1,LSL #2（R0=R1*4 通过运算一个寄存器中的地址，得到一个新的地址）
寄存器间接寻找：LDR R0, [R1]（将R1寄存器中的地址，去存储器中找到对应存储单元的值，赋值给R0）
寄存器间接基址偏移寻址：LDR R0, [R1, #-4]（使用R1的值进行运算，这里是减去4后得到的结果作为地址，去存储器中找到对应存储单元的值，赋值给R0）


int a = 0;
在汇编中变成：开辟一个存储单元，把0放入R0寄存器，然后再把R0寄存器的数据存入存储单元
MOV R0 #0
STR R0, [R11, #0x14_+var20] ->
注意：变量要看存储单元地址，不要以为是寄存器，简单是可以这么看，但如何寄存器是变量，那得要多少寄存器。
寄存器只是一个桥梁，和存储器即存储单元地址交换的东西。
寄存器数量是有限的，寄存器一般包括15个通用寄存器(R0～R14)，及一个或两个状态寄存器，以及程序计数器(PC)





