### 一、内存泄漏检测 

#### 1、线下 
##### ① LeakCanary

```java
Debug包开LeakCanary，检查是否有内存泄漏的情况发生
```

##### ② AS Profiler

```java
在测试阶段，对负责的模块进行自查
1、查看新开发的模块是否有内存异常情况（内存泄漏、内存抖动现象）
2、如果模块是功能性迭代，则需要比对内存在开发前与开发后变化是否健康。
```



  #### 2、线上 - KOOM

在线上使用监控框架，并不会是全量开启的，都需要通过后台配置判断是否需要开启。



##### KOOM改良

###### 减少误报

```java
KOOM存在的问题：误报（阈值监控方式带来的弊端就是存在误报）
假设到达了某个阈值，然后触发hprof分析逻辑。在内存分析中发现了一个Activity泄漏（KOOM认为，在内存中存活的Activity对象，它的mDestroyed和mFinish为true，那么这个Activity对象就存在泄露风险，就会执行上报）。
但是这个Activity对象并不一定是真的泄漏了，有可能是GC还没来得及回收，所有这个Activity对象还留在内存中。这种情况就属于误报。

改造KOOM：
1、在分析hprof阶段，它会帮我们分析是否有Activity、Fragment存在泄漏的，这个阶段将发现的Activity信息、以及GCRoot链信息缓存起来，并且增加个泄漏回调，给到上层。
2、上层再 Application#registerActivityLifecycleCallbacks 在 Activity 回调 onDestory 的时候缓存起来（弱引用）
private val map = hashMapOf<String, WeakReference<Activity>>()
override fun onActivityDestroyed(activity: Activity) {
		map[activity.localClassName] = WeakReference(activity)
}
3、当收有泄漏回调的时候，通过上报的 Activity信息 从map里边获取该Activity对象，开启一个定时轮询，检查这个Activity对象是否会被回收，如果超时了还没被回收，认为是真泄漏了。
4、那么就可以把这个Activity信息以及GCRoot链信息，收集最真正的上报。这样就能减少误报
  
同样的Fragment也能这样处理。
```



###### 泄漏空处理

```java
基于 减少误报 的改造逻辑延伸。
在确认了Activity是真泄漏后，进行空壳处理。
将Activity内所有的View，Listener、Drawable 等可能存在的引用关系切断。只泄漏个空壳Activity（参考Matrix - ResourceCanary - ActivityLeakFixer）
  
同样的Fragment也能这样处理。
```



### 二、内存监控 

####  以前项目线下&线上

```java
========================================
内存数据监控器：
项目启动后会启动一个轮询线程，每3分钟获取一下内存数据。
其中包括 Java堆使用情况、线程数量、GC数量以及耗时等。
注意：GC数量以及耗时有一定的性能，线上的话只在重点模块才会收集。
========================================
内存数据上报：
触顶上报：虚拟内存使用超85%，是个非常危险的信号。GC会变得更加频发，容易造成OOM和卡顿。
内存不足上报：onTrimMemory/onLowMemory
OOM上报：try/catch

上报次数记录：记录触发上报的次数

开启hprof收集策略：如果累计上报次数超过一定数量，则开启hprof收集。
  1、只针对android8.0以下的设备，因为这些设备OOM发生的概率会比较高。
  2、hprof防止过大会进行裁剪（基于Matrix-ResourceCanary的裁剪逻辑），该裁剪逻辑在android8.0以下效果显著。
========================================
线下包：默认开启内存数据监控器，关闭上报。
线上包：内存数据监控器、上报机制后台可配置；后台也可主动抓取目标设备数据。
```



#### 内存监控数据获取 

##### 1、虚拟内存

```java
大小限制：大多情况下为 4GB（32位）或512GB（64位）
当前状态：读取/proc/pid/status并解释VmSize字段
具体分析：读取/proc/pid/smaps，分析mapping及各个内存大小相关的字段
```

##### 2、Java堆（largeHeap可获取更大的堆空间）

```java
大小限制：Runtime.getRuntime().maxMemory()
当前使用：Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()
具体分析：到处进程的Hprof
  Dubug.dumpHprofData(String fileName)
	adb shell am dumpheap <pid> <file_path>
```

##### 3、FD数量（进程的fd是有最大限制的，fd耗尽也会发生OOM）

```java
大小限制：读取进程状态 /proc/pid/limits，并解释Max open files字段
当前状态：读取进程文件 /proc/pid/fd，计算文件数量
具体分析：遍历进程文件 /proc/pid/fd，并通过Os.readlink解释文件链接
```

##### 4、线程数量

```java
当前状态：读取进程状态 /proc/pid/status，并解释Threads字段
具体分析：调用Thread.getAllStackTraces() 获取当前所有线程的信息，包括线程名、调用栈及状态等
```

##### 5、Native内存

```java
通常说的Native内存是相对于Java堆而言的，Java堆区的内存有虚拟机代为申请和释放，Java层的业务代码无需关心。
Native内存主要说的是由业务动态申请的内存，一般是业务so库，业务代码是c/c++实现的，常用的方式就是调用 malloc函数申请内存，调用free释放内存。
这些内存的申请都需要合理的释放否则会导致内存不足。可结合Debug.getMemoryInfo()以及/proc/pid/smap文件来分析。

当前使用：读取nativePss，它是本进程内native层独占的内存和与其他进程共享内存的均摊的总和
具体分析：hook 业务每次malloc和free函数，记录每次内存的申请和释放，并获取到对应的堆栈，最后进行统计分析。
```

##### 6、GC次数以及耗时

```java
//6.0之前：
long allocCount = Debug.getGlobalAllocCount();
long allocSize = Debug.getGlobalAllocSize();
long gcCount = Debug.getGlobalGcInvocationCount();
//6.0之后：
Debug.getRuntimeStat("art.gc.gc-count");
Debug.getRuntimeStat("art.gc.gc-time");
Debug.getRuntimeStat("art.gc.blocking-gc-count");
Debug.getRuntimeStat("art.gc.blocking-gc-time");
```

##### 7、VSS/RSS/PSS/USS

| Item | 全称                  | 含义     | 等价                         |
| :--- | :-------------------- | :------- | :--------------------------- |
| USS  | Unique Set Size       | 物理内存 | 进程独占的内存               |
| PSS  | Proportional Set Size | 物理内存 | PSS= USS+ 按比例包含共享库   |
| RSS  | Resident Set Size     | 物理内存 | RSS= USS+ 包含共享库         |
| VSS  | Virtual Set Size      | 虚拟内存 | VSS= RSS+ 未分配实际物理内存 |

```java
概念=================================================
VSS：Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）
	一个进程总共可访问的地址空间，其大小还包括了可能不在RAM中的内存（VSS很少用于判断进程的真实内存使用量）
  
RSS：Resident Set Size 实际使用物理内存（包含共享库占用的内存）
  一个进程在RAM中真实存储的总内存。但是RSS还是可能会造成误导，因为它仅仅表示该进程所使用的所有共享库的大小，它不  管有多少个进程使用该共享库，该共享库仅被加载到内存一次。所以RSS并不能准确反映单进程的内存占用情况。 
  
PSS：Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）
  与RSS不同，它按比例表示使用的共享库，例如：如果有三个进程都使用了一个共享库，共占用了30页内存。那么PSS将认为每个进程分别占用该共享库10页的大小。 PSS是非常有用的数据，因为系统中所有进程的PSS都相加的话，就刚好反映了系统中的总共占用的内存。 而当一个进程被销毁之后， 其占用的共享库那部分比例的PSS，将会再次按比例分配给余下使用该库的进程。这样PSS可能会造成一点的误导，因为当一个进程被销毁后，PSS不能准确地表示返回给全局系统的内存。
  
USS：Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）
  一个进程所占用的私有内存。即该进程独占的内存（USS是非常非常有用的数据，因为它反映了运行一个特定进程真实的边际成本（增量成本）。当一个进程被销毁后，USS是真实返回给系统的内存。当进程中存在一个可疑的内存泄露时，USS是最佳观察数据）
  
一般来说内存占用大小有如下规律：VSS >= RSS >= PSS >= USS

  
命令查看=================================================
adb查看：adb shell procrank（根据不同进程的内存占用情况，从大到小的顺序排列的VSS/RSS/PSS/USS）
PID       Vss      Rss      Pss      Uss     Swap    PSwap    USwap    ZSwap  cmdline
19463  1876424K  176128K   49493K   35400K    8952K    4827K    4652K    1650K  system_server
19595  1282664K  163112K   41045K   28216K   12428K    8236K    8060K    2816K  com.android.systemui
25401  1258300K  121836K   28611K   18552K   27728K   23593K   23420K    8068K  com.android.launcher3
21342  1254156K  132608K   25632K   15012K   34224K   30012K   29836K   10263K  com.android.settings
...
  
  
获取方法=================================================
Debug.MemoryInfo memoryInfo = new Debug.MemoryInfo();
Debug.getMemoryInfo(memoryInfo);

api
dalvikPrivateDirty、dalvikSharedDirty、dalvikPss
nativePrivateDirty、nativeSharedDirty、nativePss
otherPrivateDirty、otherSharedDirty、otherPss
  
表示
dalvikPrivateDirty(USS) + dalivikSharedDirty == dalvikPSS
nativePrivateDirty + nativePrivateDirty == nativePSS
otherPrivateDirty + otherPrivateDirty == otherPSS

dalvik：是指dalvik所使用的内存。
native：是被native堆使用的内存。
other：是除dalvik和native使用的内存。但是具体是指什么呢？至少包括在C\C++分配的非堆内存，比如分配在栈上的内存。

private：是指私有的，非共享的。
share：是指共享的内存。
PSS：实际使用的物理内存（比例分配共享库占用的内存）
```



### 三、图片优化与监控 

#### 1、统一图片加载库 
​    能够通过加载库帮我们统一加载、缓存图片，当系统内存紧张的时候，可以及时做一些处理。例如：释放图片下缓存，停止加载任务等。
​    例如：项目主要使用Glide。连svga加载也使用glide加载

#### 2、图片压缩

```java
色深："色彩的深度"，表示一个像素点用多少bit来存储色值。（数字图像参数）
位深：跟硬件相关的对象一律使用“位深”来描述（物理硬件参数）
例如：某张图片100*100 色深32位(ARGB_8888)，保存时位深度为24位
加载到内存中占大小：100 * 100 * (32 / 8)
存储到文件中占大小：100 * 100 * (24 / 8) * 压缩率

压缩方法有两种：1、质量压缩；2、尺寸压缩。
质量压缩：保持图片宽高以及占用内存不变的情况下，改变Bitmap的质量。（https://cloud.tencent.com/developer/article/1006307）
ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
//format：压缩格式，JPEG（有损）、PNG（无损，quality参数会不起作用）、WEBP（有损或无损，有损比JPEG更加省空间）
//quality：为0～100，0表示最小体积，100表示最高质量
bitmap.compress(Bitmap.CompressFormat.JPEG, quality, outputStream);

实现原理：
Java层函数 -> Native函数 -> Skia函数 -> 对应第三库函数（例如libjpeg）
（Skia在Android中提供了基本的画图和简单的编解码功能。可以挂接其他的第三方编码解码库或者硬件编解码库，例如libpng、libjpeg、libgif 等。bitmap.compress(Bitmap.CompressFormat.JPEG...)，实际会调用libjpeg.so动态库进行编码压缩）


哈夫曼算法：
文件中可能会出现五个值a,b,c,d,e，其二进制为
a. 1010
b. 1011
c. 1100
d. 1101
e. 1110
定长算法下最优（最前面的一位数字是 1，其实是浪费掉了）
a. 010
b. 011
c. 100
d. 101
e. 110

哈夫曼算法对定长算法进行了改进。给信息赋予权重，即为信息加权。
假设 a 占据了 60%，b 占据了 20%， c 占据了 20%，d,e 都是 0%
a:010  (60%)
b:011  (20%)
c:100  (20%)
d:101  (0%)
e:110  (0%)
在这种情况下，我们可以使用哈夫曼树算法再次优化为：
a:1
b:01
c:00
就是出现频率高的字母使用短码，对出现频率低的使用长码，不出现的直接就去掉。最后abcde的哈夫曼编码就对应：1 01 00

所以这个算法一个很重要的思路是必须知道每一个元素出现的权重，能够知道每一个元素的权重那么就能够根据权重动态生成一个最优的哈夫曼表。
怎么去获取每一个元素，对于图片就是每一个像素中argb的权重。只能去循环整个图片的像素信息，这无疑是非常消耗性能的。

Android在使用libjpeg，压缩默认使用的是 默认哈夫曼表，而不是 图像数据计算哈弗曼表。
//标志位
optimize_coding=FALSE //使用默认哈夫曼表
optimize_coding=TRUE  //使用图像数据计算哈弗曼表（比默认哈夫曼表体积缩小2倍）
Google在初期考虑到手机的性能瓶颈，计算图片权重这个阶段非常占用CPU资源的同时也非常耗时，因为此时需要计算图片所有像素 argb 的权重，这也是 Android 的图片压缩率对比 iOS 来说差了一些的原因之一。

从Android7.0 版本开始，optimize_code标示已经设置为了TRUE，也就是默认使用图像生成哈夫曼表。



尺寸压缩：改变Bitmap的宽高以及占用内存（https://cloud.tencent.com/developer/article/1006352?from=article.detail.1006307）
也叫重采样，放大图像称为上采样（upsamping），缩小图像称为下采样（downsampling）。主要讨论缩小图像。
Android中图片重采样提供了两种方法，一种是邻近采样（Nearest Neighbour Resampling），另一种是双线性采样（Bilinear Resampling）

邻近采样：inSampleSize（inDensity搭配inTargetDensity使用，效果跟inSampleSize是一样的）
BitmapFactory.Options options = new BitmapFactory.Options();
//设置取样大小。它的作用是：设置int类型后，假如设为4。则宽和高都为原来的1/4，宽高都减少了自然内存也降低了。（google推荐用2的倍数）
options.inSampleSize = 2; 
Bitmap compress = BitmapFactory.decodeFile("xxx.png", options);

邻近采样采用邻近点插值算法
邻近采样比较粗暴，采样率设置为2。那么就是两个像素选一个留下，另一个直接抛弃。
例如：每个像素红绿相间的图片。邻近采样为2的时候，图片直接变成绿色了。


双线性采样：Matrix
//方式一
Bitmap bitmap = BitmapFactory.decodeFile("xxx.png");
//双线性采样使用的是双线性內插值算法，参考源像素相应位置周围2x2个点的值，根据相对位置取对应的权重，经过计算之后得到目标图像。
//双线性内插值算法在图像的缩放处理中具有抗锯齿功能, 是最简单和常见的图像缩放算法.
Matrix matrix = new Matrix();
matrix.setScale(0.5f, 0.5f);
bm = Bitmap.createBitmap(bitmap, 0, 0, bit.getWidth(), bit.getHeight(), matrix, true);

//方式二，最终也是走方式一的
Bitmap bitmap = BitmapFactory.decodeFile("/sdcard/test.png");
Bitmap compress = Bitmap.createScaledBitmap(bitmap, bitmap.getWidth()/2, bitmap.getHeight()/2, true);

双线性采样 采用双线性内插值算法
参考了源像素相应位置周围2x2个点的值，根据相对位置取对应的权重，经过计算之后得到目标图像。
双线性内插值算法在图像的缩放处理中具有抗锯齿功能，是最简单和常见的图像缩放算法。
当对相邻2x2个像素点采用双线性內插值算法时，所得表面在邻域处是吻合的，但斜率不吻合，并且双线性内插值算法的平滑作用可能使得图像的细节产生退化，这种现象在上采样时尤其明显。

两个采样算法对比
邻近采样：最快的，效率最高；产生比较明显的锯齿（尤其是文字内容多的图片）；
双线性采样：抗锯齿。


双立方／双三次采样（Bicubic Resampling）
采用的是双立方／双三次插值算法
双立方／双三次插值算法更进一步参考了源像素某点周围4x4个像素。
Android中并没有原生支持，可以通过ffmpeg来支持，具体的实现在 libswscale/swscale.c 文件中：FFmpeg Scaler Documentation。
双立方/双三次插值算法经常用于图像或者视频的缩放，它能比双线性内插值算法保留更好的细节质量。
```



#### 3、图片监控（仅线下使用）

监控ImageView填充图片的合理性，参考代码：https://github.com/leavesCZY/ASM_Transform


    实现：1、Gradle Transform + ASM，在编译时将所有父类为ImageView的class，将其父类替换成我们的监控ImageView。
         2、xml里使用的不都是ImageView吗，为啥还能替换？？？
         原因：在layout xml解析的过程中，如果发现节点是ImageView，实例化的对象并不是ImageView，而是AppCompatImageView。
         所以我们替换AppCompatImageView的父类成监控ImageView，也就是将所有ImageView替换了。
         3、当我们当调用setImageDrawable、setImageBitmap等方法的时候发起检查（检查在IdleHandler中执行），检查图片是否过大、是否超过View大小等问题。
         4、一旦发现异常，就会在app内通知提醒开发人员。
    
    技术点：
    Gradle Transform：允许第三方以插件的形式，在打包成dex之前过程中操作class文件。
    我们插件只需要继承Transform类，去遍历所有.class文件的所有方法，然后进行修改再对源文件进行替换，即可以达到插入代码的目的。
    （每个Transform都是一个gradle task，编译器中的TaskManager将每个Transform串连起来，第一个Transform接收javac编译的结果，及已经拉取的第三方依赖（jar、aar），还有asset资源。这些编译的中间产物，在Transform组成的链条上流动，每个Transform节点可以对class进行处理再传递给下一个Transform。我们常见的混淆，Desugar等逻辑，它们的实现如今都是封装在一个个Transform中，而我们自定义的Transform，会插入到这个Transform链条的最前面。文章：https://www.jianshu.com/p/cf90c557b866）
    
    ASM：字节码操作框架，可用来动态生成字节码或者对现有的类进行增强。ASM可以直接生成二进制的class字节码，也可以在class被加载进虚拟机前动态改变其行为，比如方法执行前后插入代码，添加成员变量，修改父类，添加接口等等。（文章：https://www.jianshu.com/p/29e9b03c0796）



#### 4、Drawable使用注意

```java
各个不同的文件夹对应的具体密度是多少？
0			nodpi
0-120 		ldpi
120-160		mdpi（48x48）
160-240		hdpi（72x72）
240-320		xhdpi（96x96）
320-480		xxhdpi（144x144）
480-640		xxxhdpi（192x192）
图片在低dpi的目录，那图片会被认为是为低密度设备需要的，现在要显示在高密度设备上，图片会进行放大。
图片在高dpi的目录，那图片会被认为是为高密度设备需要的，现在要显示在低密度设备上，图片会进行缩放。
图片在nodpi目录，则无论设备dpi为多少，保留原图片大小，不进行缩放


各个文件夹该放置多大分辨率的图片？
scale = 设备dpi / 图片所在drawable目录对应的最大dpi

假设当前的设备密度是480dpi, 72x72的图分别放在 xxhdpi 和 xhdp ，两种情况下图片各占多少内存？（假设现在是RGB565格式（2个字节））
xxhdpi:（72 * 72 * 2）*（480/480）= 10368字节
xhdpi:（72 * 72 * 2）*（480/320）= 15552字节
如果在开发时不恰当的将高分辨的图片放在低密度的文件夹里，很可能在高密度的设备上显示的时候会OOM，因为它们会进行放大！！

drawable文件夹的匹配规则
1.根据设备的密度，找到屏幕密度匹配的drawable文件夹，在里边找
2.屏幕密度匹配的drawable文件夹没找到，先更高密度的drawable中找，如果没找到再去更高密度drawable中找
3.如果高密度的drawable都没有，就去nodpi里边找
4.如果nodpi也没有，就去低密度drawable中找
5.如果所有drawable都找不到，就报错
```





### 四、年份区分设备的性能 

```java
facebook的device-year-class库区分设备性能。

根据不用设备的性能来制定策略。
低端机用户可以 关闭复杂的动画 或 "重功能" 或 使用565格式的图片或更小的缓存内存等等。
例如：
    跳过大内存的礼物动效的加载以及播放；
    动态点赞动效的跳过等负责动效的跳过；
    后台根据设备分开返回动效背景、动效头饰改为静态；
    图片加载设置RGB_565格式等。
```



### 五、对象优化 

#### 1、大对象

```java
统一的缓存管理，方便我们在系统内存紧张的时候，释放缓存。
```



#### 2、小对象（提防内存抖动）

```java
避免频繁创建对象；有频繁创建对象的场景需引入对象池（享元模式）。
```



#### 3、单例缓存的对象优化

```java
单例中的缓存的对象：是否可以降维到ViewModel；
如果某个模块才会使用到的，退出模块的时候记得清空。
```



#### 4、容器类选用

```java
Android提供了SparseArray系列类 以及 ArrayMap<K, V> 类。
它们都比HashMap更加轻量，在数据量小的情况下性能更优。K&V场景可以优先想到它们。
```



### 六、其他优化

##### 1、多进程 
​    Zygote在fork子进程之后，会给它初始化一些资源。（一个空进程也会占用几MB+内存）
​    例如：Resources的sPreloadedDrawables、sPreloadedColorDrawables列表就是Zygote为我们预加载的。如果进程没有界面可以通过反射将这些资源释放。

##### 2、dex、so优化

适当降低dex、so的大小



### 七、兜底策略 

##### 1、泄漏模块的兜底策略
在Activity走onDestory之后，将Activity添加到WeakRerefrence，延迟30s监控是否回收。
如果未回收则主动释放泄漏的Activity持有的ViewTree的背景图和ImageView图片，以及DrawingCache，监听器等等资源。
（Fragment同样也带有这个机制，但是默认是关闭的，因为大部分的Fragment都是跟Activity共存亡的，少部分存在替换场景这些场景的Fragment才需要开启。）

##### 2、OOM兜底策略：try/catch
捕获到OOM的时候，主动清除缓存、降低Bitmap format、关闭部分动效等

##### 3、物理内存不住的兜底策略
使用onTrimMemory/onLowMemory

收到回调的时候，主动清除缓存、降低Bitmap format、关闭部分动效等



### 八、数值量化内存优化成果 

```java
1、待机的情况下内存占用率
2、重点模块的内存占用率
对比优化前后的内存占用率

3、OOM率 - bugly上报oom次数的统计
统计优化前后的OOM率

4、GC次数以及耗时
统计优化前后的GC次数与耗时情况
```



### 九、内存问题

#### 1、内存抖动

```java
原因：频繁GC引起。
现象：内存波动图形呈锯齿状；应用出现卡顿；出现内存碎片，容易引发OOM。
Dalvik虚拟机尤为明显。ART虚拟机做了大量优化，内存分配和GC效率相比提升了5~10倍。出现内存抖动的概率会小很多。

常见案例：
1、字符串使用加号拼接（StringBuilder替代。初始化时设置容量，减少StringBuilder的扩容。）
2、资源复用（使用全局缓存池，以重用频繁申请和释放的对象。结束后需手动释放池中的对象。）
3、减少不合理的对象创建（onDraw、getView中创建的对象尽量进行复用；避免在循环中不断创建局部变量。）
4、使用合理的数据结构（SparseArray类族、ArrayMap来替代 HashMap）
```

#### 2、内存泄漏

```java
原因：对象被持有导致无法释放 或 不能按照对象正常的生命周期进行释放。
现象：可用内存减少，容易引发OOM。
分析工具：
    MemoryProfiler（as自带的）
    LeakCanary（dump的分析会影响到主进程，整个进程会卡住）
    Koom（fork dump，能在dump分析的时候而不影响到进程）
```

#### 3、OOM

```java
原因：在内存中，无法申请到一块对应大小的连续内存导致的。
现象：程序抛出OOM异常。

OOM类型：
java.lang.OutOfMemoryError: Could not allocate JNI Env
fd申请失败：进程的fd耗尽（一个进程限制是有fd个数限制的，一般是2、3万，不过有少部分设备会限制到1024）
查看fd限制数量：adb shell ulimit -a
当前进程占用fd数：lsof | grep <进程号> | wc -l （需root）
watch -n 2 'adb shell su lsof | grep <进程号> | wc -l'（watch命令定时监控）
当前进程fd信息：ls -la proc/{pid}/fd/

Android Fd泄漏问题分析文章：https://www.jianshu.com/p/befd4b86cc42


java.lang.OutOfMemoryError: pthread_create (1040KB stack) failed: Try again
开启线程失败：虚拟内存不足，无法开启线程（启动一个线程需要先分配1040KB（1024 + 8 + 8）虚拟内存，再去启动的）

创建线程源码与OOM分析文章：https://blog.csdn.net/Tencent_Bugly/article/details/78542324
```

#### 4、Native内存泄漏（待学习）

```java
分析和定位内存泄漏问题的核心在于分配函数的统计和栈回溯。
如果只知道内存分配点不知道调用栈会使问题变得格外复杂，增加解决成本，因此两者缺一不可。
  
Android Native C++内存泄漏的调试：https://zhuanlan.zhihu.com/p/433548715
分析Native层内存泄漏：https://blog.csdn.net/u010307119/article/details/53144176
```



#### 5、物理内存不足

```java
设备物理内存告急会通知各个进程（onTrimMemory/onLowMemory），这类的问题难以分析以及定位。并且整个系统可能会出现卡死甚至重启，ANR频发（随便找个进程背锅）。
如果遇到这种情况，老老实实给系统解解压（释放缓存、在后台的话可以自销毁等）。
  
维护良好的系统环境，人人有责！！！
```



### 十、学习记录

##### 学习目标

```java
Matrix-ResourceCanary 重点学习泄漏后的兜底、Hprof的裁剪（加深对Hprof文件的理解）、dump hprof方式 ✅
LeakCanary 重点学习各个组件泄漏的检测方式 ✅
KOOM 重点学习阀值检测、dump hprof方式、利用Shark分析hprof、线程泄漏。✅
     native堆监控（待学习）。
 
学习总结：
Matrix-ResourceCanary：兜底策略值得学习；没了...
LeakCanary：yyds；业内标杆；线下监控王者；
KOOM：慢慢成为业内标杆；线上监控的王者；好多值得学习的东西；
	优点：阈值监控方案确实减少了很多GC
	缺点：阈值监控不一定能第一时间发现泄漏，无法及时对泄露的Activity、Fragment做兜底策略
```



#### 0、Hprof文件 

```java
Hprof是由J2SE支持的一种二进制堆转储格式，Hprof文件保存了当前java堆上所有的内存使用信息，能够完整的反映虚拟机当前的内存状态。

Hprof文件基本数据类型为：u1、u2、u4、u8，分别表示1byte、2byte、4byte、8byte的内容
Hprof文件组成：由一个FixedHead 以及 多个Record组成。
	FixedHead包括：
  	Version（u1，格式名称及版本）
  	ID size（u4，字符串、对象、堆栈等信息的id的长度，很多record的具体信息需要通过id来查找）
    Time（u8，时间戳）
  Record包括：
  	Tag（u1，Record类型）
    Time（u4，时间戳）
    Length（u4，Body字节长度）
    Body（u4，Record内容）

enum HprofTag { //Record Tag类型
  HPROF_TAG_STRING = 0x01,            // 字符串（保存着所有的字符串，在解析时可通过索引id引用）
  HPROF_TAG_LOAD_CLASS = 0x02,        // 类（包括类内部的变量布局，父类的信息等等）
  HPROF_TAG_UNLOAD_CLASS = 0x03,
  HPROF_TAG_STACK_FRAME = 0x04,        // 栈帧
  HPROF_TAG_STACK_TRACE = 0x05,        // 堆栈
  ...
  HPROF_TAG_HEAP_DUMP = 0x0C,            // 堆（内存占用与对象引用的详细信息）
  HPROF_TAG_HEAP_DUMP_SEGMENT = 0x1C,
  HPROF_TAG_HEAP_DUMP_END = 0x2C,
  ...
};
每一个Tag及其对应的内容可参考HPROF Agent（上边有链接）。
比如String record：Tag为0x01，那么当前record就是字符串，第一部分信息是字符串ID，第二部分就是字符串的内容。

堆信息，即Tag为 HPROF_TAG_HEAP_DUMP 或 HPROF_TAG_HEAP_DUMP_SEGMENT 时
那么Body由一系列子Record组成，这些子Record同样使用Tag来区分：
enum HprofHeapTag { //堆Record的子Record Tag类型
  HPROF_ROOT_UNKNOWN = 0xFF,
  HPROF_ROOT_JNI_GLOBAL = 0x01,        // native 变量
  HPROF_ROOT_JNI_LOCAL = 0x02,
  ...
  HPROF_CLASS_DUMP = 0x20,            // 类
  HPROF_INSTANCE_DUMP = 0x21,         // 实例对象
  HPROF_OBJECT_ARRAY_DUMP = 0x22,     // 对象数组
  HPROF_PRIMITIVE_ARRAY_DUMP = 0x23,  // 基础类型数组

  // Android.（Android增加了额外的9个）
  HPROF_HEAP_DUMP_INFO = 0xfe,
  HPROF_ROOT_INTERNED_STRING = 0x89,
  HPROF_ROOT_FINALIZING = 0x8a,  // Obsolete.
  HPROF_ROOT_DEBUGGER = 0x8b,
  HPROF_ROOT_REFERENCE_CLEANUP = 0x8c,  // Obsolete.
  HPROF_ROOT_VM_INTERNAL = 0x8d,
  HPROF_ROOT_JNI_MONITOR = 0x8e,
  HPROF_UNREACHABLE = 0x90,  // Obsolete.
  HPROF_PRIMITIVE_ARRAY_NODATA_DUMP = 0xc3,  // Obsolete.
};
其中比较重要的是HPROF_HEAP_DUMP_INFO。
Android上将java堆分为Heap-App、Heap-Image、Heap-Zygote三块，这个Tag的作用是切换当前的堆，该Tag后面紧跟着一个u4的堆id 和 一个堆名称id
比如出现一个HPROF_HEAP_DUMP_INFO Record，且该Record表示Heap-Image，那么表示后续所有Record中的类、对象、GCRoot对象均在Heap-Image中存储，直到下一个HPROF_HEAP_DUMP_INFO出现为止。


使用AS Profiler工具分析Hprof文件：
View Heap
1、app heap：当前APP从堆中分配的内存
2、image heap：系统启动映像，包含启动期间预加载的类。 此处的分配保证绝不会移动或消失
3、zygote heap：zygote是所有APP进程的母进程，linux的进程使用COW技术，所有的APP共享zygote的内存空间，因此堆的话也继承了，并且zygote的这些空间不允许写入，为了加快java的启动和运行速度，zygote在启动时预加载了许多资源和代码，这样可以提高APP的运行速率.
源码

Classes：该堆上的Class对象数
Leaks：该堆上泄漏的数量！！！！！（需要重点关注有这个标记类）
Count：该堆上对象数

Depth：从gc roots到选中的当前对象的引用链最短长度
Allcoations：该类的对象数量
Native Size：native对象的内存大小
Shallow Size：对象本身占用的内存，不包括它引用的其他实例
  [类定义] + 父类fields所占空间 + 自身fields所占空间 + [alignment]
Retained Size：当实例A被回收时, 可以同时被回收的实例的Shallow Size之和。
  所以进行内存分析时，应该重点关注Retained Size较大的实例; 或者可以通过Retained Size判断出某A实例内部使用的实例是否被其他实例引用。
Reference：eference里面主要是类的引用关系，可以通过引用关系，一层一层的查看类是如何泄漏的。
```

文章参考

android中hprof文件分析：https://blog.csdn.net/u013309870/article/details/115482411
HPROF Agent：http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html#mozTocId848088



#### 1、Matrix - ResourceCanary

功能：修复内存泄漏；检测内存泄漏；抓取Hprof并对其进行裁剪。

##### ① 内存泄漏修复功能

```java
使用：需要主动调用 ResourcePlugin#ActivityLeakFixer
分析：监听registerActivityLifecycleCallbacks，在onActivityDestroyed的时候执行这几个方法
1、ActivityLeakFixer.fixInputMethodManagerLeak(activity); 
//解决InputMethodManager持有view引发的内存泄漏

2、ActivityLeakFixer.unbindDrawables(activity);
//将Activity内所有的View，Listener、Drawable 等可能存在的引用关系切断
 public static void unbindDrawables(Activity ui) {
        final long startTick = System.currentTimeMillis();
        if (ui != null && ui.getWindow() != null && ui.getWindow().peekDecorView() != null) {
            final View viewRoot = ui.getWindow().peekDecorView().getRootView();
            try {
                unbindDrawablesAndRecycle(viewRoot);
                if (viewRoot instanceof ViewGroup) ((ViewGroup) viewRoot).removeAllViews();
            } catch (Throwable thr) { ... }
        } 
   			...
    }

  private static void unbindDrawablesAndRecycle(View view) {
        ...
        recycleView(view); //将大量Listener置为空
        //根据不用的View，进行不用的处理
        if (view instanceof ImageView) { //Drawable置为空
            recycleImageView((ImageView) view);
        }
        if (view instanceof TextView) { //Drawable置为空，如果是EditText，还执行fixTextWatcherLeak
            recycleTextView((TextView) view);
        }
        ... //好多View的处理
        if (view instanceof ViewGroup) { //继续寻找子View继续执行unbindDrawablesAndRecycle
            recycleViewGroup((ViewGroup) view);
        }
    }

3、ActivityLeakFixer.fixViewLocationHolderLeakApi28(activity);
//修复Android P中，ViewGroup$ViewLocationHolder$mRoot的内存泄漏
```

##### ② 内存泄漏监控

```java
逻辑：开启定时轮询监控器，对走了onDestroye的Activity进行监控。
     将该Activity对象加入设置为弱引用，轮询发现该Activity未被回收，多次发现之后认为该Activity泄漏了。
     执行导出hprof以及上报操作。

源码分析：
Activity泄漏监控逻辑：
ActivityRefWatcher#start（开始监控）
   1、注册ActivityLifecycleCallbacks
   2、执行scheduleDetectProcedure()：开启一个定时轮询的任务（mScanDestroyedActivitiesTask）
ActivityLifecycleCallbacks#onActivityDestroyed 
  -> ActivityRefWatcher#pushDestroyedActivityInfo
  	 1、创建DestroyedActivityInfo对象（会生产该Activity的uuid，并且弱引用该Activity）
     2、将DestroyedActivityInfo对象缓存到mDestroyedActivityInfos容器
  -> 延迟2s执行 ActivityRefWatcher#triggerGc（主动触发一次GC）

 定时轮询任务 mScanDestroyedActivitiesTask#execute
  -> ActivityRefWatcher#triggerGc（主动触发一次GC）
  -> 遍历mDestroyedActivityInfos容器
  	 1、DestroyedActivityInfo对象的 Activity弱引用==null，就移除自身（因为该Activity不泄露）
     2、DestroyedActivityInfo对象的 Activity弱引用!=null, 对象内的mDetectedCount属性自增1
     3、DestroyedActivityInfo对象的 mDetectedCount 没到临界次数，ActivityRefWatcher#triggerGc
     4、DestroyedActivityInfo对象的 mDetectedCount 到的临界次数（发现Activity泄漏了）
  			就移除该自身对象，并且执行 mLeakProcessor#process 导出hprof
  
 Hprof导出逻辑：
  -> mLeakProcessor#process（BaseLeakProcessor是根据开发者配置的DumpMode参数来创建）
  	 配置AUTO_DUMP就会创建AutoDumpProcessor（直接在该进程导出hprof）
     配置FORK_DUMP就会创建ForkDumpProcessor（fork子进程导出hprof）
  	 配置...
  -> ForkDumpProcessor#process（以FORK_DUMP配置为例）
  	 -> MemoryUtil#dump -> memory_utils.cpp#forkDump -> 先暂停主进程所有线程，然后再fork出子进程（主进程那边会恢复所有暂停的线程），最后执行dump hprof。
     -> getWatcher().markPublished -> 记录该Activity为已上报（防止多次上报）
     -> getHeapDumpHandler().process -> CanaryWorkerService#shrinkHprofAndReport（对hprof进行裁剪跟上报）
```

##### ③ hprof裁剪

```java
CanaryWorkerService#shrinkHprofAndReport（JobScheduler方式）-> CanaryWorkerService#onHandleWork -> CanaryWorkerService#doShrinkHprofAndReport -> 
  	裁剪：new HprofBufferShrinker().shrink(hprofFile, shrinkedHProfFile);
		上报：CanaryResultService.reportHprofResult(...);

吐槽一下：官方说的10倍以上的瘦身效果。是相对android8.0-而言的。
  	     android8.0+之后Bitmap像素数据都放native了，瘦身效果微乎其微。

裁剪逻辑：
1、读取 Hprof 文件
2、记录 Bitmap 和 String 类信息
3、移除 Bitmap buffer 和 String value 之外的基础类型数组
4、将同一张图片的 Bitmap buffer 指向同一个 buffer id，移除重复的 Bitmap buffer
5、其它数据原封不动地输出到新文件中
注意：Bitmap的mBuffer字段在android8.0被移除了，所以无法分析android8.0的设备的重复Bitmap。
  
//HprofReader负责读取数据，然后交给HprofVisitor去处理
public void shrink(File hprofIn, File hprofOut) throws IOException {
    final HprofReader reader = new HprofReader(new BufferedInputStream(is));
    //第一次读取
    //HprofInfoCollectVisitor作用：记录Bitmap和String类信息
    reader.accept(new HprofInfoCollectVisitor());
    is.getChannel().position(0);  //让指针回到0，准备第二次读取
    
    //第二次读取
    //HprofKeptBufferCollectVisitor作用：记录所有String对象的valueID 以及 Bitmap对象的BufferID与其对应的数组本身
    //接着分析所有Bitmap对象的buffer数组，如果其MD5相等，说明是同一张图片，就将这些重复的bufferID映射起来，以便之后将它们指向同一个buffer数组，删除其它重复的数组
    reader.accept(new HprofKeptBufferCollectVisitor());
    is.getChannel().position(0); //让指针回到0，准备第三次读取
   
    //第三次读取
    //HprofBufferShrinkVisitor作用：读取到数据之后就由 HprofWriter 输出到新的文件
    //在写入之前，会由HprofBufferShrinkVisitor进行一些特殊操作
    //输出Bitmap对象需要将相同的Bitmap数组指向同一个bufferID，以便接下来剔除重复的buffer数据
    //基础类型数组，如果不是Bitmap中的mBuffer字段 或 String中的value字段，则不写入到新文件中
    reader.accept(new HprofBufferShrinkVisitor(new HprofWriter(os)));
}
```



#### 2、LeakCanary2.0

##### ① 自动初始化

```java
AppWatcherInstaller继承自ContentProvider，ContentProvider在Application执行onCreate之前就会被安装，然后就会执行ContentProvider#onCreate。
AppWatcher.manualInstall(application) 方法就是在ContentProvider#onCreate里边执行的。
```

##### ② Activity泄漏监控

```java
AppWatcher#appDefaultWatchers -> ActivityWatcher(xx, xxx)
  -> ActivityWatcher#install
     1、注册 ActivityLifecycleCallbacks 监听
	   2、在 onActivityDestroyed 回调中，对avtivity对象进行监控（ObjectWatcher#watch）。让ObjectWatcher来进行对象回收的监控。

  
ObjectWatcher有两个集合：
1） private val watchedObjects = mutableMapOf<String, KeyedWeakReference>() 用来存放要观察对象的key和弱引用,代码会为每个观察的对象生成一个唯一的key和弱应用

2）private val queue = ReferenceQueue<Any>()
这个队列 和 watchedObjects联合使用。
当弱引用中的对象被回收后，这个弱引用会被放到这个队列中。
换句话说就是只要存在这个队列中弱引用，就代表这个弱引用中所包含的对象被回收了。

 
ObjectWatcher#watch分析：
1、先移除watchedObjects 和 queue 集合里面已经回收对象的弱引用。

2、通过uuid为当前观察的对象生成一个唯一的key,并把对象用弱应用包起来，放到watchedObjects 这个集合中，同时把queue 和弱应用关联起来。

3、checkRetainedExecutor.execute {moveToRetained(key) }
这里是个延迟任务，延迟五秒后再次执行1操作，这个期间对象可能已经被回收了，所以需要再次移除一次。

4、执行了3操作后，就可以通过watchedObjects 集合找到没有被回收的对象了。这时候就可以获取到没有被回收的对象的个数，大于0，进行一次gc操作（Runtime.getRuntime().gc()，源码上注释这个操作比system.gc()更可能触发gc操作）。

5、再次获取未被回收的个数,这一步会有几个判断条件
 1）如果个数小于5，不做操作等待5秒再次进行检查未回收的个数，一直循环，直到大于等于5个或者等于0个，为了防止频发回收堆造成卡顿。
 2）大于5个后，如果处于debug模式，会再等20秒，再次执行4操作。防止debug模式会减慢回收
 3）距离上次堆栈分析是否大于等于1分钟，如果没有超过一分钟，也需要再次延迟（1分钟-当前距离上次的时间）再次循环4操作

6、如果上面的条件都符合了，就可以开始进行堆栈的分析了
 1）获取到内容文件 Debug.dumpHprofData(heapDumpFile.absolutePath)
 2）objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)该操作是去掉以前已经分析过的对象，也就是去除掉之前的没有回收掉的对象，不在本次分析范围内
 3）HeapAnalyzerService开启IntentService服务进行分析（HAHA库进行分析hprof文件）
 4）把结果插入数据库（泄漏区分了应用本身的内存泄漏和类库的内存泄漏），并且发送通知
```



##### ③ Fragment、ViewModel、RootView、Service泄漏监控

```java
对象泄漏监控的通用方法：发现目标对象在没有利用价值的时候，拿到目标对象加入到泄漏监控里边。

Fragment & ViewModel 泄漏监控
AppWatcher#appDefaultWatchers -> FragmentAndViewModelWatcher(xx, xxx)
  -> FragmentAndViewModelWatcher#install
		 1、注册 ActivityLifecycleCallbacks 监听
     2、在 onActivityCreated 回调的时候，执行多个Watcher
     		AndroidOFragmentDestroyWatcher
     		AndroidXFragmentDestroyWatcher
     		AndroidSupportFragmentDestroyWatcher
  
  -> 以 AndroidXFragmentDestroyWatcher 为例 -> AndroidXFragmentDestroyWatcher#invoke
     1、通过activity对象获取FragmentManager，然后注册 FragmentLifecycleCallbacks 监听
     2、执行ViewModelClearedWatcher#install -> 目标是activity对象
     3、在 onFragmentCreated 回调的时候，执行ViewModelClearedWatcher#install -> 目标是fragment对象
     4、在 onFragmentViewDestroyed / onFragmentDestroyed 的时候（fragment到了没有利用价值的时候，加入泄漏监控）
  	 	  onFragmentViewDestroyed 对 fragment.view 进行监控（ObjectWatcher#watch）
        onFragmentDestroyed 对 fragment 进行监控（ObjectWatcher#watch）
  
   -> ViewModelClearedWatcher#install(storeOwner: ViewModelStoreOwner, ...)
  分别传入了activity对象、fragment对象（因为在AndroidX，Activity、Fragment都实现了ViewModelStoreOwner接口）
     1、通过ViewModelProvider创建一个ViewModelClearedWatcher的ViewModel对象，并将它和Activity或Fragment关联起来
     当ViewModel回收时会调用ViewModel#onCleared，所以走到ViewModelClearedWatcher#onCleared方法中
     2、ViewModelClearedWatcher在构造函数中反射 ViewModelStore#mMap 获取到存放ViewModel的容器
     3、ViewModelClearedWatcher#onCleared 通过获取容器中的ViewModel对象，对它们加入泄漏监控
  
  
  
RootView 泄漏监控
AppWatcher#appDefaultWatchers -> RootViewWatcher(xx, xxx) 
-> RootViewWatcher#install
   1、创建OnRootViewAddedListener（它继承自OnRootViewsChangedListener）
   2、注册这个OnRootViewAddedListener监听器
-> OnRootViewAddedListener（当View添加到Window的时候就会回调）
   1、判断rootView类型，看是否需要监控
   2、对rootView执行 View#addOnAttachStateChangeListener，关注view的依附状态
   3、当View回调onViewDetachedFromWindow的时候，将view对象加入泄漏监控
  
RootViewsSpy#install
  1、hook WindowManagerGlobal#mViews（ArrayList<View> mViews），并且代理其mViews属性，监听mViews的add、remove方法。
  2、当有View从mViews添加、移除的时候，通知所有的 OnRootViewsChangedListener#onRootViewsChanged
  
  
Service 泄漏监控
AppWatcher#appDefaultWatchers -> ServiceWatcher(xx, xxx)
-> ServiceWatcher#install
  1、hook ActivityThread#mServices属性（ArrayMap<IBinder, Service>）
  2、hook ActivityThread#mH，设置Callback，接收Service销毁的msg（为了切线程组件的生命周期都是走mH的）
    当接收Service销毁的msg，从msg数据中获取token，然后通过token从 mServices 获取Serivce对象
    将Service对象弱引用后丢给servicesToBeDestroyed容器（WeakHashMap<IBinder, WeakReference<Service>>）
  3、hook ActivityManager（IActivityManager），代理所有这些binder接口
    只关注 serviceDoneExecuting 方法，当发现执行了 serviceDoneExecuting 方法
    判断servicesToBeDestroyed里边是否还存在Service对象，如果存在将Service对象加入泄漏监控
  （可以理解为 Service销毁的msg：Service#onDestroy前；serviceDoneExecuting：Service#onDestroy后。）
```

文章参考：
LeakCanary2.0版本原理简单查看：https://www.jianshu.com/p/850c974e984b
LeakCanary原理分析：https://zhuanlan.zhihu.com/p/57425510
LeakCanary 原理剖析：https://cloud.tencent.com/developer/article/1675655



#### 3、KOOM 2.0

##### ① 基本知识

```java
KOOM主要功能：Java堆泄漏监控、Native堆泄漏监控、Thread泄漏监控
Java堆泄漏 -> OOMMonitor
官方说明：https://github.com/KwaiAppTeam/KOOM/blob/master/koom-java-leak/README.zh-CN.md
Native堆泄漏 -> LeakMonitor
官方说明：https://github.com/KwaiAppTeam/KOOM/blob/master/koom-native-leak/README.zh-CN.md
Thread泄漏 -> ThreadLeakMonitor
官方说明：https://github.com/KwaiAppTeam/KOOM/blob/master/koom-thread-leak/README.zh-CN.md

添加监控阀值配置：MonitorManager#addMonitorConfig

配置类型：
OOMMonitorConfig：java
LeakMonitorConfig：native
ThreadMonitorConfig：thread

轮询监控器：在KOOM初始化之后（CommonConfig#build()），就会启动一个HandlerThread用于所有的轮询监控的
LoopMonitor类 就是基于这个HandlerThread的Handler来实现轮询器的，其中
startLoop 启动Loop
stopLoop 关闭Loop
call() 每次轮询都执行的函数，支持返回LoopState（返回Terminate也会 关闭Loop）
监控器都是继承自LoopMonitor的，比如OOMMonitor、LeakMonitor、ThreadLeakMonitor

进程前后台监控：监控器都关注前后台情况，进入后台会关闭监控，回到前台才继续启动
ProcessLifecycleOwner.get().lifecycle.addObserver(object : LifecycleEventObserver {
    override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) {
      when (event) {
        Lifecycle.Event.ON_START -> _isForeground = true //进程进入前台
        Lifecycle.Event.ON_STOP -> _isForeground = false //进程进入后台
        else -> Unit
      }
      ...
    }
  })
```



##### ② Java Heap泄漏监控

监控原理：

- 周期性查询Java堆内存、线程数、文件描述符数等资源占用情况，当连续多次超过设定阈值或突发性连续快速突破高阈值时，触发镜像采集
- 镜像采集采用`虚拟机supend->fork虚拟机进程->虚拟机resume->dump内存镜像`的策略，将传统Dump冻结进程20s的时间缩减至20ms以内
- 基于shark执行镜像解析，并针对shark做了一系列调整用于提升性能，在手机设备测即可执行离线内存泄露判定与引用链查找，生成分析报告

###### 监控阈值与dump hprof流程

```java
监控器轮询：
OOMMonitor#call -> OOMMonitor#trackOOM -> OOMMonitor#dumpAndAnalysis

//OOMMonitor#trackOOM 解析
private fun trackOOM(): LoopState {
    //1、获取、计算一些数据，用于后续分析
    //java堆信息，堆总大小、使用量、计算使用百分比等（缓存在 SystemInfo#javaHeap）
    //进程状态，vss、rss、线程数等（缓存在 SystemInfo#procStatus）
    //设备内存信息，ram总大小、未使用大小、已使用大小等（缓存在 SystemInfo#memInfo）
    SystemInfo.refresh() 

    //2、检查跟踪的指标，是否有超过阈值的
    //mOOMTrackers：跟踪的指标，其中包括 堆指标（HeapOOMTracker）、线程指标（ThreadOOMTracker）
    //fd指标（FdOOMTracker）、物理内存指标（PhysicalMemoryOOMTracker）、快照内存指标（FastHugeMemoryOOMTracker）
    //Tracker#track()：该方法检查是否有跟踪的指标超标的（SystemInfo缓存的数据进行分析，阈值是开发者可配置的）
    mTrackReasons.clear()
    for (oomTracker in mOOMTrackers) {
      if (oomTracker.track()) { //如果发现有超标的，将原因加入到mTrackReasons中
        mTrackReasons.add(oomTracker.reason())
      }
    }

    //3、是否需要dump hprof进行分析
    //mTrackReasons不为空、开发者配置了允许dump hprof
    if (mTrackReasons.isNotEmpty() && monitorConfig.enableHprofDumpAnalysis) {
      if (isExceedAnalysisPeriod() || isExceedAnalysisTimes()) {
        MonitorLog.e(TAG, "Triggered, but exceed analysis times or period!")
      } else {
        async { //dump hprof并且分析
          dumpAndAnalysis()
        }
      }

      return LoopState.Terminate
    }
    return LoopState.Continue
  }

//OOMMonitor#dumpAndAnalysis 解析
private fun dumpAndAnalysis() {
    ...
    ForkJvmHeapDumper.getInstance().run {
      dump(hprofFile.absolutePath)
    }

    MonitorLog.i(TAG, "end hprof dump", true)
    Thread.sleep(1000) // make sure file synced to disk.
    MonitorLog.i(TAG, "start hprof analysis")
    
    //开始分析
    startAnalysisService(hprofFile, jsonFile, mTrackReasons.joinToString())
    ...
  }

//ForkJvmHeapDumper#dump 解析
public synchronized boolean dump(String path) {
    ...
    boolean dumpRes = false;
    //ForkJvmHeapDumper#suspendAndFork -> native_bridge#suspendAndFork -> hprof_dump#HprofDump::SuspendAndFork
    int pid = suspendAndFork(); //挂起主进程所有线程 并且 fork
    if (pid == 0) { // Child process
      Debug.dumpHprofData(path); //执行dump hprof
      exitProcess();
    } else if (pid > 0) { // Parent process
      //恢复主进程所有线程 并且 等待子进程退出
      //由于在HandlerThread这个子线程里边等待，所有是不影响主线程工作的
      dumpRes = resumeAndWait(pid);
    }
    ...
    return dumpRes;
  }

为什么需要先suspendVM然后再fork?
在dump前，通过ScopedSuspendAll(构造函数中执行SuspendAll)执行了暂停所有java线程的操作，以防止在dump的过程中java堆发生变化，当dump结束后通过ScopedSuspendAll析构函数进行ResumeAll

dump前需要暂停所有java线程，而子进程只保留父进程执行fork操作的线程，在子进程中执行SuspendAll触发暂停是永远等不到其他线程返回结果的(详见thread_list.cc中行SuspendAll的实现)，经过仔细分析SuspendAll的过程，我们发现，可以先在主进程执行SuspendAll，使ThreadList中保存的所有线程状态为suspend，之后fork，子进程共享父进程的ThreadList全局变量，子进程可以欺骗虚拟机，使其以为子进程全部线程已经完成了暂停操作，接下来子进程就可以愉快的dump hprof了，而父进程可以立刻执行ResumeAll恢复运行。

这里有一个小技巧，SuspendAll没有对外暴露Java层的API，我们可以通过C层间接暴露的art::Dbg::SuspendVM来调用，dlsym拿到“_ZN3art3Dbg9SuspendVMEv”的地址调用即可，ResumeAll同理，注意这个函数在android 11以后已经被去除了，需要另行适配。Android 7之后对linker做了限制（即dlopen系统库失效），快手自研了kwai-linker组件，通过caller address替换和dl_iterate_phdr解析绕过了这一限制。
```

###### 利用hprof分析泄漏流程

```java
OOMMonitor#startAnalysisService -> HeapAnalysisService#startAnalysisService（startService HeapAnalysisService（继承自IntentService）） -> HeapAnalysisService#onHandleIntent

override fun onHandleIntent(intent: Intent?) {
    ...
    val hprofFile = intent?.getStringExtra(Info.HPROF_FILE)
    val jsonFile = intent?.getStringExtra(Info.JSON_FILE)
    val rootPath = intent?.getStringExtra(Info.ROOT_PATH)
    ...

    //解析Hprof文件然后封装成 HprofHeapGraph 对象（将不同内容封装为不同的record，然后将record转为索引化的index封装，之后查找内容可以通过index去索引到。）
    buildIndex(hprofFile)
    ...
    //将intent传过来的一些记录数据用来构建一个HeapReport对象，方便后续将该对象写入json文件
    buildJson(intent)
    ...
    /*
    遍历镜像（HprofHeapGraph对象）的所有实例，做以下操作

    1、检查是否存在泄漏 或 是否存在内存超标对象 
    ① Activity：mDestroyed和mFinish为true
      原因是 Activity Leak
      记录到mLeakingObjectIds、classObjectCounterMap
    ② Fragment：mCalled为true和fragment manager为空（可以认为fragment已经destroy）
      原因是 Fragment Leak
      记录到mLeakingObjectIds、classObjectCounterMap
    ③ Bitmap：width * height >= 768 * 1366 + 1
      原因是 Bitmap Size Over Threshold
      记录到mLeakingObjectIds、classObjectCounterMap、mLeakModel.leakObjects（大对象记录缓存）
    ④ Nativeallocation / NativeAllocationThunk / Window ：只要发现有它们就记录下来
      记录到classObjectCounterMap

    上边被记录到classObjectCounterMap的数据，最后都会转换到 mLeakModel.classInfos

    2、检查基本类型数组：arraySize >= 256 * 1024（原因是 Primitive Array Size Over Threshold）
    加入到大对象记录 mLeakModel.leakObjects

    3、检查对象数组：arraySize >= 256 * 1024
    加入到大对象记录 mLeakModel.leakObjects

    mLeakModel（这个对象HeapReport()，最后会转成Json的）
    */
    filterLeakingObjects()
    ...
    //遍历mLeakingObjectIds，为记录的泄漏目标GcRoot路径（代码巨多，有空研究）
    findPathsToGcRoot()
    ...
    //将mLeakModel对象转为Json字符串，写入文件中
    fillJsonFile(jsonFile)
    ...
    System.exit(0);
  }
```



##### ③ Thread 泄漏监控

监控原理：

- hook pthread_create/pthread_exit 等线程方法，用于记录线程的生命周期和创建堆栈，名称等信息
- 当发现一个joinable的线程在没有detach或者join的情况下，执行了pthread_exit，则记录下泄露线程信息
- 当线程泄露时间到达配置设置的延迟期限的时候，上报线程泄露信息

###### 监控器启动流程

```java
启动函数 ThreadMonitor#startTrack 分析：
  1、ThreadMonitor#handleNativeInit（重点关注）
     作用：启动native的消息队列；hook线程相关的创建、退出函数。
  2、执行startLoop，它就是监控器常规启动方法而已

ThreadMonitor#handleNativeInit 分析：
  1、loadSoQuietly("koom-thread") 加载对应so
  2、NativeHandler#start -> jni_bridge.cpp#NativeHandler_start -> koom.cpp#Start
  	2.1、通过创建sHookLooper对象（sHookLooper = new HookLooper()），启动一个native消息队列
        2.1.1、由于HookLooper继承自looper类，所以也会走父类looper的构造函数
        2.1.2、looper的构造函数里边会开启一个线程，让线程执行函数（looper::trampoline）
        2.1.3、looper::trampoline 函数里边又调用了 looper::loop 函数
        2.1.4、looper::loop 函数 while(true) 一个消息队列。
           	   类似android消息队列，轮询消息有消息来就取出丢给 looper::handle 函数处理
               looper::handle里就一个打印，实际的逻辑在子类HookLooper里边（HookLooper::handle）
		2.2、利用xhook，hook线程相关的创建、退出函数
         函数调用链：koom::ThreadHooker::Start -> ThreadHooker::InitHook 
          		     -> ThreadHooker::HookLibs -> ThreadHooker::RegisterSo

//2.2 ThreadHooker::RegisterSo分析：
bool ThreadHooker::RegisterSo(const std::string &lib, int source) {
  if (IsLibIgnored(lib)) {
    return false;
  }
  auto lib_ctr = lib.c_str();
  ...
  xhook_register(lib_ctr, "pthread_create", reinterpret_cast<void *>(HookThreadCreate), nullptr);
  xhook_register(lib_ctr, "pthread_detach", reinterpret_cast<void *>(HookThreadDetach), nullptr);
  xhook_register(lib_ctr, "pthread_join", reinterpret_cast<void *>(HookThreadJoin), nullptr);
  xhook_register(lib_ctr, "pthread_exit", reinterpret_cast<void *>(HookThreadExit), nullptr);
  return true;
}
```

###### 监控器轮询流程

```java
轮询流程分析：
1、定时向native的消息队列发消息（ACTION_REFRESH），进行线程泄漏上报
2、遍历 leakThreadMap 容器，判断线程是否到达了线程泄漏判断时长，如果达到则认为是泄漏了
3、将泄漏的线程信息写入Json，上报到Java层

函数调用链 
  ThreadMonitor#call 
  -> ThreadMonitor#handleThreadLeak 
  -> NativeHandler#refresh 
  -> jni_bridge.cpp#NativeHandler_refresh -> koom.cpp#Refresh
  -> sHookLooper->post(ACTION_REFRESH, info);
	   //info：new SimpleHookInfo(Util::CurrentTimeNs());缓存当前时间
     //这里只是往HookLooper这个消息队列，发送 ACTION_REFRESH 消息

//HookLooper::handle 处理消息的地方
void HookLooper::handle(int what, void *data) {
  looper::handle(what, data);
  switch (what) {
    ...
    case ACTION_REFRESH: { //处理 ACTION_REFRESH 消息
      ...
      auto info = static_cast<SimpleHookInfo *>(data);
      //holder：ThreadHolder对象，是在HookLooper构造函数里边创建的。
      holder->ReportThreadLeak(info->time);
      delete info;
      break;
    }
    ...
  }
}

//ThreadHolder::ReportThreadLeak
void ThreadHolder::ReportThreadLeak(long long time) {
  ...
  //threadLeakDelay是开发者在java层可配置的，判定线程泄漏的时长
  auto delay = threadLeakDelay * 1000000LL;  //ms->ns 
  ...
  for (auto &item : leakThreadMap) {
    //条件1：线程是否到达了线程泄漏判断时长
    //条件2：该线程是否已经上报过
    if (item.second.exitTime + delay < time && !item.second.thread_reported) {
      ...
      needReport++;
      item.second.thread_reported = true;
      WriteThreadJson(writer, item.second); //将泄漏线程的信息，写入Json
    }
  }
  ...
  if (needReport) {
    JavaCallback(jsonBuf.GetString()); //上报Json给java层（NativeHandler#nativeReport）
    ...
  }
}
```

###### Linux线程小知识

```java
Linux线程有两种状态
joinable状态：线程函数返回时 或 pthread_exit时 都不会释放线程所占用堆栈和线程描述符
  注意：Linux创建线程默认是joinable状态，只有当你调用了pthread_join之后这些资源才会被释放。
  如果线程退出了资源都不释放就是线程泄漏了！！！
unjoinable状态：这些资源 线程函数返回时 或 pthread_exit时 自动会被释放

让线程资源释放的方法：
  1、pthread_create时指定：pthread_attr_t的detachstate属性配置PTHREAD_CREATE_DETACHED，表示新线程与进程中其他线程脱离同步。
     注意：如果配置了DETACHED的线程，其他线程无法等待该线程退出 并且 不能用pthread_join()来同步。
  2、在线程创建后调用 pthread_detach(pthread_self())，detach自己。
  3、适当的地方调用 pthread_join
```



###### leakThreadMap 收集泄漏线程流程

```java
收集流程分析：
1、hook pthread_create中，将线程信息记录（线程id、调用栈、线程分离标志），加入 threadMap 容器
2、hook pthread_detach、pthread_join中，从 threadMap 容器找到对应item，将线程分离标志设为true
3、hook pthread_exit中，从 threadMap 容器找到对应item判断线程分离标志是否为true，如果不是则认为是线程泄漏，加入到 leakThreadMap 容器中。
```

1、先从hook pthread_create函数出发

```java
//pthread_create -> ThreadHooker::HookThreadCreate
int ThreadHooker::HookThreadCreate(pthread_t *tidp, const pthread_attr_t *attr,void *(*start_rtn)(void *), void *arg) {
  if (hookEnabled() && start_rtn != nullptr) {
    auto time = Util::CurrentTimeNs();
    //StartRtnArg对象：用于缓存原本的arg、start_rtn、缓存ThreadCreateArg对象
    auto *hook_arg = new StartRtnArg(arg, Util::CurrentTimeNs(), start_rtn);
    auto *thread_create_arg = hook_arg->thread_create_arg; //ThreadCreateArg对象：用于记录堆栈信息的
    void *thread = koom::CallStack::GetCurrentThread(); //获取当前java线程？
    if (thread != nullptr) { //如果是java线程，记录java调用栈？
      koom::CallStack::JavaStackTrace(thread,hook_arg->thread_create_arg->java_stack);
    }
    //记录native调用栈？
    koom::CallStack::FastUnwind(thread_create_arg->pc,koom::Constant::kMaxCallStackDepth);
    //记录获取调用栈的时长
    thread_create_arg->stack_time = Util::CurrentTimeNs() - time;
    //再包装一层将逻辑丢到我们自己的函数
    return pthread_create(tidp, attr,
                          reinterpret_cast<void *(*)(void *)>(HookThreadStart),
                          reinterpret_cast<void *>(hook_arg));
  }
  return pthread_create(tidp, attr, start_rtn, arg);
}

//ThreadHooker::HookThreadStar
void ThreadHooker::HookThreadStart(void *arg) {
  auto *hookArg = (StartRtnArg *)arg;
  pthread_attr_t attr;
  pthread_t self = pthread_self();
  int state = 0;
  if (pthread_getattr_np(self, &attr) == 0) {
    //获取该线程分离属性情况
    pthread_attr_getdetachstate(&attr, &state);
  }
  int tid = (int)syscall(SYS_gettid);
  //HookAddInfo对象：缓存tid、线程id、是否有线程分离属性、调用栈信息
  auto info = new HookAddInfo(tid, Util::CurrentTimeNs(), self,state == PTHREAD_CREATE_DETACHED,
                              hookArg->thread_create_arg);
  //给消息队列发送消息
  sHookLooper->post(ACTION_ADD_THREAD, info);
  
  //执行原本pthread应该要执行的函数
  void *(*start_rtn)(void *) = hookArg->start_rtn;
  void *routine_arg = hookArg->arg;
  delete hookArg;
  start_rtn(routine_arg);
}

//msg ACTION_ADD_THREAD -> HookLooper::handle -> ThreadHolder::AddThread
//将信息缓存到 threadMap 容器里边
void ThreadHolder::AddThread(int tid, pthread_t threadId, bool isThreadDetached, int64_t start_time, ThreadCreateArg *create_arg) {
  ...
  auto &item = threadMap[threadId];
  item.Clear();
  item.thread_internal_id = threadId;
  item.thread_detached = isThreadDetached;
  item.startTime = start_time;
  item.create_time = create_arg->time;
  item.id = tid;
  ...
}
```

2、其实hook函数分析

```java
//pthread_detach -> ThreadHooker::HookThreadCreate -> msg ACTION_DETACH_THREAD -> ThreadHolder::DetachThread
void ThreadHolder::DetachThread(pthread_t threadId) {
  ...
  threadMap[threadId].thread_detached = true; //将线程分离属性改为true
  ...
}

//pthread_join -> ThreadHooker::HookThreadJoin -> msg ACTION_JOIN_THREAD -> ThreadHolder::JoinThread
void ThreadHolder::JoinThread(pthread_t threadId) {
  ...
  threadMap[threadId].thread_detached = true; //也是将线程分离属性改为true
  ...
}

//pthread_exit -> ThreadHooker::HookThreadExit -> msg ACTION_EXIT_THREAD -> ThreadHolder::ExitThread
void ThreadHolder::ExitThread(pthread_t threadId, std::string &threadName, long long int time) {
  ...
  auto &item = threadMap[threadId];
  ...
  item.exitTime = time;
  item.name.assign(threadName);
  if (!item.thread_detached) { //该线程的分离属性不为true，该线程不会自动释放资源
    //泄露了，加入泄漏的leakThreadMap
    leakThreadMap[threadId] = item;
  }
  threadMap.erase(threadId); //从 threadMap 容器中移除
  koom::Log::info(holder_tag, "ExitThread finish");
}
```



##### ④ Native Heap泄漏监控（待学习）

监控原理：详情可参考 libmemunreachable ；利用 [Tracing garbage collection](https://en.wikipedia.org/wiki/Tracing_garbage_collection) 机制分析整个 Native Heap。

- hook malloc/free 等内存分配器方法，用于记录 Native 内存分配元数据「大小、堆栈、地址等」
- 周期性的使用 mark-and-sweep 分析整个进程 Native Heap，获取不可达的内存块信息「地址、大小」
- 利用不可达的内存块的地址、大小等从我们记录的元数据中获取其分配堆栈，产出泄漏数据「不可达内存块地址、大小、分配堆栈等」



文章参考：

KOOM V1.0.5 源码解析：https://juejin.cn/post/6991374693403983886#heading-16

官方：https://github.com/KwaiAppTeam/KOOM/blob/master/README.zh-CN.md



### 十一、很棒的内存优化文章推荐

```java
全民 K 歌内存篇
1线上监控与综合治理 https://mp.weixin.qq.com/s/KWaueLMZwwLSjGGJya6qFA
2虚拟内存浅析 https://mp.weixin.qq.com/s/pbLLLCXlkz6gp9ps65rMYA
3native 内存分析与监控 https://mp.weixin.qq.com/s/0cF5Q6_LXrkLAdjkXIwrVQ

抖音
Java 内存优化篇 https://blog.csdn.net/ByteDanceTech/article/details/111503373
Java OOM优化之NativeBitmap方案 https://blog.csdn.net/ByteDanceTech/article/details/124487103

微信
微信 Android 终端内存优化实践 https://cloud.tencent.com/developer/article/1362381

极客时间 Android 开发高手课
https://time.geekbang.org/column/intro/100021101?tab=catalog  

bugly Android内存优化总结&实践 
https://cloud.tencent.com/developer/article/1071719?from=article.detail.1030855

Matrix相关文章
内存泄漏监控源码分析 https://juejin.cn/post/6854573218179579912
Hprof文件分析 https://juejin.cn/post/6854573208520097799
I/O监控及原理解析 https://juejin.cn/post/6895253983767003144#heading-5

QQ音乐
Android 中图片压缩分析（上） https://cloud.tencent.com/developer/article/1006307
Android 中图片压缩分析（下） https://cloud.tencent.com/developer/article/1006352

Bitmap 位图内存的演进流程 https://sharrychoo.github.io/blog/android-source/bitmap-memory-evolution

Android内存优化分析总结 https://juejin.cn/post/7123452813656457253
```
