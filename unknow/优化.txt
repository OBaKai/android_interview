
oom
原因：在内存中，无法申请到一块对应大小的连续内存导致的。
现象：程序抛出OOM异常。

OOM类型：
java.lang.OutOfMemoryError: Could not allocate JNI Env
fd申请失败：进程的fd耗尽（一般一个进程限制1024个fd   adb shell ulimit -a ）

当前进程占用fd数：lsof | grep <进程号> | wc -l （需root）
watch -n 2 'adb shell su lsof | grep <进程号> | wc -l'（watch命令定时监控）
当前进程fd信息：ls -la proc/{pid}/fd/

Android Fd泄漏问题分析：https://www.jianshu.com/p/befd4b86cc42


java.lang.OutOfMemoryError: pthread_create (1040KB stack) failed: Try again
开启线程失败：虚拟内存不足，无法开启线程（启动一个线程需要先分配1040KB（1024 + 8 + 8）虚拟内存，再去启动的）

创建线程源码与OOM分析：https://blog.csdn.net/Tencent_Bugly/article/details/78542324


内存优化量化：
待机的情况下内存占用率
重点模块的内存占用率
OOM率 - bugly上报oom次数的统计
GC次数







（android5.0之前）Dalvik 垃圾回收机制：Mark-Sweep算法（标记-清除）：
遍历一次堆地址空间，从对象的根集对象开始标记引用对象（Mark阶段），回收没有被标记的对象占用的内存（Sweep阶段）。
缺点1：Mark阶段需要暂停应用线程两次，Sweep阶段需要暂停一次，三次的STW开销会带来卡顿。
缺点2：堆空间中给较大的对象分配空间后会导致碎片化比较严重，并且可能会导致GC调用次数变多增加开销。

（android5.0之后）ART垃圾回收机制：Concurrent Mark-Sweep算法（并发标记-清除）：
优化1：消除了第一次遍历堆地址空间的停顿，和第二次标记根集对象的停顿，并缩短了第三次处理card table的停顿，因此大大的缩短了应用程序在执行时的卡顿时间。
优化2：提出了LOS专门管理大对象的管理方法。

除此以外，还提供了丰富的GC收集器，例如继承自mark sweep的sticky mark sweep和partial mark sweep，二者的回收力度都要比full mark sweep小，因此性能上也得到了一些提升。一般情况下的收集器的主力就是sticky mark sweep, 这是对应用程序的性能影响最小的一种方式，因此大多数情况的GC表现，都要比Dalvik的GC表现更好。



三、界面流畅性优化：卡顿
Systrace：android-sdk/platform-tools/systrace/systrace.py
1、python systrace.py --time=10 -o report.html
2、操作app 10s后，systrace生成一个HTML报告
花费16.6ms以上渲染的帧用黄色或红色圆圈表示。点击一个圆圈，可查看详细报告。

systrace是在系统级显示有关进程的信息，因此很难在报告中查看某个特定时间内，您的应用程序正在执行什么方法。

代码中添加trace标记方法，并且命令需要加上 -a + 包名
Trace.beginSection("xxx");
...需要跟踪的代码
Trace.endSection();

也可以用TraceView（Systrace的图形工具）分析trace Log



四、启动速度优化：冷启动、某场景的进入





五、包体积优化：apk瘦身
压缩、混淆资源文件
移除无用的资源文件
移除无用的依赖库

动态加载so
	dlopen

插件化加载第三方sdk
    DexClassLoader