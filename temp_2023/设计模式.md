## 1、单一原则：一个类只负责一件事情

### 单一原则弊端

```java
1、代码量的增加(拆分开类的代码明显比之前增加)
2、使用成本就是所谓的理解成本增高（调用者要晓得不同的类）
```

### 单一原则分为以下五种

```java
1、方法级别的单一职责原则：一个方法只负责一件事儿（职责分拆小方法，分支逻辑分拆）
2、类级别的单一职责原则：一个类只负责一件事儿
3、类库级别的单一职责原则：一个类库应该职责清晰
4、项目级别的单一职责原则：一个项目应该职责清晰(客户端/管理后台/后台服务/定时任务/分布式引擎)
5、系统级别的单一职责原则：为通用功能拆分系统(IP定位/日志/在线统计)
```

### 例子

```java
//违背单一原则例子：不同的动物会有不同的行为，但是这里不同的行为都聚集在了 action() 方法，这是不应该的
public class Animal{
    private string name = null;
    public Animal(string name){ this.name = name; }
   
    public void action(){
        if (this.name.Equals("鸡"))
            println("flying");
        else if (this.name.Equals("牛"))
            println("walking");
        ...
    }
}

//使用：
Animal a1 = new Animal("鸡");
a1.Action();
Animal a2 = new Animal("牛");
a2.Action();


//修改后：将Animal类抽象
public abstract class Animal{
    protected string name = null;
    public AbstractAnimal(string name) { this.name = name; }
    public abstract void action();
}

public class Chicken : Animal{
  public Chicken() : base("鸡"){ }

  public override void action(){
  	println("flying");
  }
}

//使用：
Animal animal = new Chicken();               
animal.Action();
```



## 2、开闭原则：对扩展开放，对修改关闭

一个模块，应当支持扩展新的功能，并且是在不修改源代码的情况下，就能够扩展。

开闭原则，能够让模块更易于维护以及拓展。



## 3、迪米特法则：高内聚，低耦合

模块内高内聚，模块跟模块之间低耦合



## 4、依赖倒转原则：面向接口编程

依赖倒置原则：高层模块不应该依赖于低层模块，二者应该通过抽象依赖（使用者为高层，被调用者为低层）

## 例子

```java
为什么开发都喜欢用 List list = new ArrayList();
而不是直接 ArrayList list = new ArrayList();

好处：
依赖倒转原则：依赖于抽象，不依赖于具体
能够让使用更加灵活。
比如：我提供一个方法给外部 xxx(List list)
外部可以根据它情况传入ArrayList、LinkedList等实现List接口的类

```





## 5、接口隔离原则：细节接口

```java
客户端不应该依赖它不需要的接口， 一个类对另一个类的依赖应该建立在最小的接口上；

这个原则跟自己实际工作有很大的关系，总结下来可以通过以下几点来定义接口：

1、既不能是大而全，会强迫实现没有的东西，也会依赖自己不需要的东西
2、也不能一个方法一个接口，这样面向抽象也没有意义的
按照功能的密不可分来定义接口，
而且应该是动态的，随着业务发展会有变化的，但是在设计的时候，要留好提前量，避免抽象的变化
没有标准答案，随着业务和产品来调整的
3、接口合并 Map--定位/搜索/导航 这种属于固定步骤，业务细节，尽量的内聚，在接口也不要暴露太多业务细节（就是密切相连的可以放在一个接口来实现，而不是分多个接口实现功能）
```





## 6、合成/聚合复用原则：避免使用继承

合成/聚合复用原则经常又叫做合成复用原则，它的设计原则是：要尽量使用合成/聚合，尽量不要使用继承。也就是说，我们要优先考虑使用合成、聚合来实现功能，在使用合成、聚合无法实现的情况下，才考虑使用继承来实现。

其实这里最重要的地方就是区分“has-a”和“is-a”的区别。
相对于合成和聚合，继承的缺点在于：父类的方法全部暴露给子类。父类如果发生变化，子类也得发生变化；聚合的复用的时候就对另外的类依赖的比较的少。



## 7、里氏代换原则：子类不能去修改父类的功能

任何使用基类的地方，都可以透明的使用其子类，这主要是指 继承+透明(安全，不会出现行为不一致)

继承：子类拥有父类的一切属性和行为，任何父类出现的地方，都可以用子类来代替，主要是因为：

1、父类有的，子类是必须有的（私有不继承）；如果出现了子类没有的东西，那么就应该断掉继承；

2、子类可以有自己的属性和行为，但是子类出现的地方，父类不一定能代替

3、父类实现的东西，子类就不要再写了，(就是不要new隐藏)，如果想修改父类的行为，通过abstract/virtual
